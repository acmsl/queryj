/*
                        QueryJ

    Copyright (C) 2002  Jose San Leandro Armendariz
                        jsanleandro@yahoo.es
                        chousz@yahoo.com

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    General Public License for more details.

    You should have received a copy of the GNU General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    Thanks to ACM S.L. for distributing this library under the GPL license.
    Contact info: jsanleandro@yahoo.es
    Postal Address: c/Playa de Lagoa, 1
                    Urb. Valdecabanas
                    Boadilla del monte
                    28660 Madrid
                    Spain

 ******************************************************************************
 *
 * Filename: $RCSfile$
 *
 * Author: Jose San Leandro Armendariz
 *
 * Description: Provides some useful methods when generating DAO classes
 *              via DAO template instances.
 *
<<<<<<< DAOTemplateUtils.java
=======
 * Last modified by: $Author$ at $Date$
 *
 * File version: $Revision$
 *
 * Project version: $Name$
 *
 * $Id$
 *
>>>>>>> 1.6
 */
package org.acmsl.queryj.tools.templates.dao;

/*
 * Importing some project-specific classes.
 */
import org.acmsl.queryj.tools.customsql.IdentifiableElement;
import org.acmsl.queryj.tools.customsql.ConnectionFlagsElement;
import org.acmsl.queryj.tools.customsql.CustomSqlProvider;
import org.acmsl.queryj.tools.customsql.PropertyElement;
import org.acmsl.queryj.tools.customsql.PropertyRefElement;
import org.acmsl.queryj.tools.customsql.ResultElement;
import org.acmsl.queryj.tools.customsql.ResultRefElement;
import org.acmsl.queryj.tools.customsql.ResultSetFlagsElement;
import org.acmsl.queryj.tools.customsql.SqlElement;
import org.acmsl.queryj.tools.customsql.StatementFlagsElement;

/*
 * Importing ACM-SL Commons classes.
 */
import org.acmsl.commons.utils.EnglishGrammarUtils;

/*
 * Importing some JDK classes.
 */
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

/**
 * Provides some useful methods when generating DAO classes
 * via DAO template instances.
 * @author <a href="mailto:jsanleandro@yahoo.es"
 *         >Jose San Leandro</a>
<<<<<<< DAOTemplateUtils.java
=======
 * @version $Revision$
>>>>>>> 1.6
 */
public class DAOTemplateUtils
{
    /**
     * An empty String array.
     */
    public static final String[] EMPTY_STRING_ARRAY = new String[0];

    /**
     * An empty SqlElement array.
     */
    public static final SqlElement[] EMPTY_SQLELEMENT_ARRAY =
        new SqlElement[0];

    /**
     * An empty ResultElement array.
     */
    public static final ResultElement[] EMPTY_RESULTELEMENT_ARRAY =
        new ResultElement[0];

    /**
     * An empty PropertyElement array.
     */
    public static final PropertyElement[] EMPTY_PROPERTYELEMENT_ARRAY =
        new PropertyElement[0];

    /**
     * The default connection-flags filter.
     */
    public static final String DEFAULT_CONNECTION_FLAGS_FILTER =
        "connection-flags.default";

    /**
     * The connection-flags filter for <i>find-by-primary-key</i> operation.
     */
    public static final String FIND_BY_PRIMARY_KEY_CONNECTION_FLAGS_FILTER =
        "connection-flags.find-by-primary-key";

    /**
     * The default statement-flags filter.
     */
    public static final String DEFAULT_STATEMENT_FLAGS_FILTER =
        "statement-flags.default";

    /**
     * The statement-flags filter for <i>find-by-primary-key</i> operation.
     */
    public static final String FIND_BY_PRIMARY_KEY_STATEMENT_FLAGS_FILTER =
        "statement-flags.find-by-primary-key";

    /**
     * The default resultset-flags filter.
     */
    public static final String DEFAULT_RESULTSET_FLAGS_FILTER =
        "resultset-flags.default";

    /**
     * The resultset-flags filter for <i>find-by-primary-key</i> operation.
     */
    public static final String FIND_BY_PRIMARY_KEY_RESULTSET_FLAGS_FILTER =
        "resultset-flags.find-by-primary-key";

    /**
     * An empty, 9-element String array.
     */
    private static final String[] EMPTY_9_STRING_ARRAY = new String[9];

    /**
     * The statement flags setter array.
     */
    protected static final String[] STATEMENT_FLAGS_SETTERS = new String[9];

    /**
     * The autogeneratedkeys index.
     */
    protected static final int AUTOGENERATEDKEYS_INDEX = 0;

    /**
     * The fetchsize index.
     */
    protected static final int FETCHSIZE_INDEX = AUTOGENERATEDKEYS_INDEX + 1;

    /**
     * The maxfieldsize index.
     */
    protected static final int MAXFIELDSIZE_INDEX = FETCHSIZE_INDEX + 1;

    /**
     * The maxrows index.
     */
    protected static final int MAXROWS_INDEX = MAXFIELDSIZE_INDEX + 1;

    /**
     * The querytimeout index.
     */
    protected static final int QUERYTIMEOUT_INDEX = MAXROWS_INDEX + 1;

    /**
     * The fetchdirection index.
     */
    protected static final int FETCHDIRECTION_INDEX = QUERYTIMEOUT_INDEX + 1;

    /**
     * The escapeprocessing index.
     */
    protected static final int ESCAPEPROCESSING_INDEX = FETCHDIRECTION_INDEX + 1;

    /**
     * The moreresults index.
     */
    protected static final int MORERESULTS_INDEX = ESCAPEPROCESSING_INDEX + 1;

    /**
     * The cursorname index.
     */
    protected static final int CURSORNAME_INDEX = MORERESULTS_INDEX + 1;

    /**
     * An empty, 3-element String array.
     */
    private static final String[] EMPTY_3_STRING_ARRAY = new String[3];

    /**
     * The ResultSet type index.
     */
    protected static final int TYPE_INDEX = 0;

    /**
     * The ResultSet concurrency index.
     */
    protected static final int CONCURRENCY_INDEX = TYPE_INDEX + 1;

    /**
     * The ResultSet holdability index.
     */
    protected static final int HOLDABILITY_INDEX = CONCURRENCY_INDEX + 1;

    static
    {
        STATEMENT_FLAGS_SETTERS[AUTOGENERATEDKEYS_INDEX] = null;
        STATEMENT_FLAGS_SETTERS[FETCHSIZE_INDEX] = "setFetchSize({0})";
        STATEMENT_FLAGS_SETTERS[MAXFIELDSIZE_INDEX] = "setMaxFieldSize({0})";
        STATEMENT_FLAGS_SETTERS[MAXROWS_INDEX] = "setMaxRows({0})";
        STATEMENT_FLAGS_SETTERS[QUERYTIMEOUT_INDEX] = "setQueryTimeout({0})";
        STATEMENT_FLAGS_SETTERS[FETCHDIRECTION_INDEX] = "setFetchDirection({0})";
        STATEMENT_FLAGS_SETTERS[ESCAPEPROCESSING_INDEX] = "setEscapeProcessing({0})";
        STATEMENT_FLAGS_SETTERS[MORERESULTS_INDEX] = null;
        STATEMENT_FLAGS_SETTERS[CURSORNAME_INDEX] = "setCursorName(\"{0}\")";
    }

    /**
     * Singleton implemented as a weak reference.
     */
    private static WeakReference singleton;

    /**
     * Protected constructor to avoid accidental instantiation.
     */
    protected DAOTemplateUtils() {};

    /**
     * Specifies a new weak reference.
     * @param utils the utils instance to use.
     */
    protected static void setReference(final DAOTemplateUtils utils)
    {
        singleton = new WeakReference(utils);
    }

    /**
     * Retrieves the weak reference.
     * @return such reference.
     */
    protected static WeakReference getReference()
    {
        return singleton;
    }

    /**
     * Retrieves a DAOTemplateUtils instance.
     * @return such instance.
     */
    public static DAOTemplateUtils getInstance()
    {
        DAOTemplateUtils result = null;

        WeakReference reference = getReference();

        if  (reference != null) 
        {
            result = (DAOTemplateUtils) reference.get();
        }

        if  (result == null) 
        {
            result = new DAOTemplateUtils();

            setReference(result);
        }

        return result;
    }

    /**
     * Retrieves the connection flags for find-by-primary-key operation.
     * @param customSqlProvider the CustomSqlProvider instance.
     * @return the connection flags for given operation.
     * @precondition customSqlProvider != null
     */
    public String[] retrieveConnectionFlagsForFindByPrimaryKeyOperation(
        final CustomSqlProvider customSqlProvider)
    {
        String result[] = EMPTY_STRING_ARRAY;

        Collection t_cResult = null;

        if  (customSqlProvider != null)
        {
            Collection t_cConnectionFlags =
                filterConnectionFlags(
                    customSqlProvider.getCollection(),
                    FIND_BY_PRIMARY_KEY_CONNECTION_FLAGS_FILTER);

            if  (   (t_cConnectionFlags == null)
                 || (t_cConnectionFlags.size() == 0))
            {
                t_cConnectionFlags =
                    filterConnectionFlags(
                        customSqlProvider.getCollection(),
                        DEFAULT_CONNECTION_FLAGS_FILTER);
            }

            if  (   (t_cConnectionFlags != null)
                 && (t_cConnectionFlags.size() > 0))
            {
                Iterator t_itConnectionFlags = t_cConnectionFlags.iterator();

                t_cResult = new ArrayList();

                while  (t_itConnectionFlags.hasNext())
                {
                    t_cResult.add(
                        ((ConnectionFlagsElement) t_itConnectionFlags.next())
                            .getTransactionIsolation());
                }
            }
        }

        if  (t_cResult != null)
        {
            result = (String[]) t_cResult.toArray(result);
        }

        return result;
    }

    /**
     * Filters the connection flags from given CustomSqlProvider contents.
     * @param contents such contents.
     * @param idFilter the id filter.
     * @return the connection flags.
     * @precondition contents != null
     */
    protected Collection filterConnectionFlags(
        final Collection contents, final String idFilter)
    {
        return filterItems(contents, ConnectionFlagsElement.class, idFilter);
    }

    /**
     * Retrieves the statement flags for find-by-primary-key operation.
     * @param customSqlProvider the CustomSqlProvider instance.
     * @return the statement flags for given operation.
     * @precondition customSqlProvider != null
     */
    public String[] retrieveStatementFlagsForFindByPrimaryKeyOperation(
        final CustomSqlProvider customSqlProvider)
    {
        String result[] = EMPTY_9_STRING_ARRAY;

        if  (customSqlProvider != null)
        {
            Collection t_cStatementFlags =
                filterStatementFlags(
                    customSqlProvider.getCollection(),
                    FIND_BY_PRIMARY_KEY_STATEMENT_FLAGS_FILTER);

            if  (   (t_cStatementFlags == null)
                 || (t_cStatementFlags.size() == 0))
            {
                t_cStatementFlags =
                    filterStatementFlags(
                        customSqlProvider.getCollection(),
                        DEFAULT_STATEMENT_FLAGS_FILTER);
            }

            if  (   (t_cStatementFlags != null)
                 && (t_cStatementFlags.size() > 0))
            {
                Iterator t_itStatementFlags = t_cStatementFlags.iterator();

                // There should be only one.
                StatementFlagsElement t_Statement =
                    (StatementFlagsElement) t_itStatementFlags.next();

                result[AUTOGENERATEDKEYS_INDEX] =
                    t_Statement.getAutogeneratedKeys();

                String t_strFetchSize = null;

                if  (t_Statement.getFetchSize() != null)
                {
                    t_strFetchSize = "" + t_Statement.getFetchSize();
                }

                result[FETCHSIZE_INDEX] = t_strFetchSize;

                String t_strMaxFieldSize = null;

                if  (t_Statement.getMaxFieldSize() != null)
                {
                    t_strMaxFieldSize = "" + t_Statement.getMaxFieldSize();
                }

                result[MAXFIELDSIZE_INDEX] = t_strMaxFieldSize;

                String t_strMaxRows = null;

                if  (t_Statement.getMaxRows() != null)
                {
                    t_strMaxRows = "" + t_Statement.getMaxRows();
                }

                result[MAXROWS_INDEX] = t_strMaxRows;

                String t_strQueryTimeout = null;

                if  (t_Statement.getQueryTimeout() != null)
                {
                    t_strQueryTimeout = "" + t_Statement.getQueryTimeout();
                }

                result[QUERYTIMEOUT_INDEX] = t_strQueryTimeout;

                result[FETCHDIRECTION_INDEX] =
                    t_Statement.getFetchDirection();

                String t_strEscapeProcessing = null;

                if  (t_Statement.getEscapeProcessing() != null)
                {
                    t_strEscapeProcessing =
                        "" + t_Statement.getEscapeProcessing();
                }

                result[ESCAPEPROCESSING_INDEX] = t_strEscapeProcessing;

                result[MORERESULTS_INDEX] = t_Statement.getMoreResults();

                result[CURSORNAME_INDEX] = t_Statement.getCursorName();
            }
        }

        return result;
    }

    /**
     * Retrieves the setter methods.
     * @return the setter methods.
     */
    public String[] retrieveStatementFlagsSetters()
    {
        return STATEMENT_FLAGS_SETTERS;
    }

    /**
     * Filters the statement flags from given CustomSqlProvider contents.
     * @param contents such contents.
     * @param idFilter the id filter.
     * @return the statement flags.
     * @precondition contents != null
     */
    protected Collection filterStatementFlags(
        final Collection contents, final String idFilter)
    {
        return filterItems(contents, StatementFlagsElement.class, idFilter);
    }

    /**
     * Retrieves the resultset flags for find-by-primary-key operation.
     * @param customSqlProvider the CustomSqlProvider instance.
     * @return the resultset flags for given operation.
     * @precondition customSqlProvider != null
     */
    public String[] retrieveResultSetFlagsForFindByPrimaryKeyOperation(
        final CustomSqlProvider customSqlProvider)
    {
        String result[] = EMPTY_3_STRING_ARRAY;

        Collection t_cResult = null;

        if  (customSqlProvider != null)
        {
            Collection t_cResultSetFlags =
                filterResultSetFlags(
                    customSqlProvider.getCollection(),
                    FIND_BY_PRIMARY_KEY_RESULTSET_FLAGS_FILTER);

            if  (   (t_cResultSetFlags == null)
                 || (t_cResultSetFlags.size() == 0))
            {
                t_cResultSetFlags =
                    filterResultSetFlags(
                        customSqlProvider.getCollection(),
                        DEFAULT_RESULTSET_FLAGS_FILTER);
            }

            if  (   (t_cResultSetFlags != null)
                 && (t_cResultSetFlags.size() > 0))
            {
                Iterator t_itResultSetFlags = t_cResultSetFlags.iterator();

                // There should be only one.
                ResultSetFlagsElement t_ResultSet =
                    (ResultSetFlagsElement) t_itResultSetFlags.next();

                String t_strType = null;

                if  (t_ResultSet.getType() != null)
                {
                    t_strType = t_ResultSet.getType();
                }

                result[TYPE_INDEX] = t_strType;

                String t_strConcurrency = null;

                if  (t_ResultSet.getConcurrency() != null)
                {
                    t_strConcurrency = t_ResultSet.getConcurrency();
                }

                result[CONCURRENCY_INDEX] = t_strConcurrency;

                String t_strHoldability = null;

                if  (t_ResultSet.getHoldability() != null)
                {
                    t_strHoldability = t_ResultSet.getHoldability();
                }

                result[HOLDABILITY_INDEX] = t_strHoldability;
            }
        }

        return result;
    }

    /**
     * Filters the resultset flags from given CustomSqlProvider contents.
     * @param contents such contents.
     * @param idFilter the id filter.
     * @return the resultset flags.
     * @precondition contents != null
     */
    protected Collection filterResultSetFlags(
        final Collection contents, final String idFilter)
    {
        return filterItems(contents, ResultSetFlagsElement.class, idFilter);
    }

    /**
     * Filters given CustomSqlProvider contents according to given class name
     * and filter (optional).
     * @param contents such contents.
     * @param itemClass the class to filter.
     * @param idFilter the id filter (optional).
     * @return the connection flags.
     * @precondition contents != null
     * @precondition itemClass != null
     */
    protected Collection filterItems(
        final Collection contents,
        final Class itemClass,
        final String idFilter)
    {
        Collection result = new ArrayList();

        Iterator t_itContents = contents.iterator();

        while  (t_itContents.hasNext())
        {
            Object t_CurrentItem = t_itContents.next();

            if  (   (t_CurrentItem != null)
                 && (t_CurrentItem.getClass().isAssignableFrom(itemClass)))
            {
                if  (   (idFilter == null)
                     || (filterById(
                             (IdentifiableElement) t_CurrentItem, idFilter)))
                {
                    result.add(t_CurrentItem);
                }
            }
        }

        return result;
    }

    /**
     * Filters given element by its id.
     * @param element the element.
     * @param idFilter the filter.
     * @return <code>true</code> if both identifiers match.
     * @precondition element != null
     * @precondition idFilters != null
     */
    protected boolean filterById(
        final IdentifiableElement element, final String idFilter)
    {
        return idFilter.equalsIgnoreCase(element.getId());
    }

    /**
     * Checks whether given result element is suitable of being
     * included in the DAO layer associated to a concrete table.
     * @param resultElement the result element.
     * @param tableName the table name.
     * @param customSqlProvider the <code>CustomSqlProvider</code> instance.
     * @return <code>true</code> if it should be included.
     * @precondition resultElement != null
     * @precondition tableName != null
     * @precondition customSqlProvider != null
     */
    public boolean matches(
        final ResultElement resultElement,
        final String tableName,
        final CustomSqlProvider customSqlProvider)
    {
        boolean result = false;

        SqlElement[] t_aSqlElements =
            findSqlElementsByResultId(
                resultElement.getId(), customSqlProvider);

        if  (t_aSqlElements != null)
        {
            for  (int t_iIndex = 0;
                      t_iIndex < t_aSqlElements.length;
                      t_iIndex++)
            {
                if  (matches(
                         tableName,
                         t_aSqlElements[t_iIndex].getDao(),
                         EnglishGrammarUtils.getInstance()))
                {
                    result = true;
                    break;
                }
            }
        }

        return result;
    }

    /**
     * Finds all <code>SqlElement</code> instances associated to given
     * result element.
     * @param resultId such id.
     * @param customSqlProvider the <code>CustomSqlProvider</code> instance.
     * @return all such entities.
     * @precondition resultId != null
     * @precondition customSqlProvider != null
     */
    public SqlElement[] findSqlElementsByResultId(
        final String resultId,
        final CustomSqlProvider customSqlProvider)
    {
        Collection t_cResult = new ArrayList();

        Collection t_cElements = customSqlProvider.getCollection();

        if  (t_cElements != null)
        {
            Iterator t_itElements = t_cElements.iterator();

            if  (t_itElements != null)
            {
                Object t_CurrentItem = null;

                while  (t_itElements.hasNext())
                {
                    t_CurrentItem = t_itElements.next();

                    if  (t_CurrentItem instanceof SqlElement)
                    {
                        ResultRefElement t_ResultRefElement =
                            ((SqlElement) t_CurrentItem).getResultRef();

                        if  (   (t_ResultRefElement != null)
                             && (resultId.equals(t_ResultRefElement.getId())))
                        {
                            t_cResult.add(t_CurrentItem);
                        }
                    }
                }
            }
        }

        return (SqlElement[]) t_cResult.toArray(EMPTY_SQLELEMENT_ARRAY);
    }

    /**
     * Checks whether given table name matches the DAO id.
     * @param tableName the table name.
     * @param daoId the DAO id.
     * @return <code>true</code> if they match.
     * @precondition tableName != null
     * @precondition daoId != null
     */
    public boolean matches(
        final String tableName, final String daoId)
    {
        return matches(tableName, daoId, EnglishGrammarUtils.getInstance());
    }

    /**
     * Checks whether given table name matches the DAO id.
     * @param tableName the table name.
     * @param daoId the DAO id.
     * @param englishGrammarUtils the <code>EnglishGrammarUtils</code>
     * instance.
     * @return <code>true</code> if they match.
     * @precondition tableName != null
     * @precondition daoId != null
     * @precondition englishGrammarUtils != null
     */
    protected boolean matches(
        final String tableName,
        final String daoId,
        final EnglishGrammarUtils englishGrammarUtils)
    {
        boolean result = false;

<<<<<<< DAOTemplateUtils.java
        String t_strTableInLowerCase = tableName.trim().toLowerCase();

        result = daoId.equalsIgnoreCase(t_strTableInLowerCase);

        if  (!result)
        {
            String t_strSingularName =
                englishGrammarUtils.getSingular(t_strTableInLowerCase);

            result = daoId.equalsIgnoreCase(t_strSingularName);
        }
=======
        String t_strTableInLowerCase = tableName.trim().toLowerCase();
>>>>>>> 1.6

<<<<<<< DAOTemplateUtils.java
        if  (!result)
        {
            String t_strPluralName =
                englishGrammarUtils.getPlural(t_strTableInLowerCase);

            result = daoId.equalsIgnoreCase(t_strPluralName);
        }
=======
        result = daoId.equalsIgnoreCase(t_strTableInLowerCase);

        if  (!result)
        {
            String t_strSingularName =
                englishGrammarUtils.getSingular(t_strTableInLowerCase);

            result = daoId.equalsIgnoreCase(t_strSingularName);
        }

        if  (!result)
        {
            String t_strPluralName =
                englishGrammarUtils.getPlural(t_strTableInLowerCase);

            result = daoId.equalsIgnoreCase(t_strPluralName);
        }
>>>>>>> 1.6

        return result;
    }

    /**
     * Retrieves all <code>SqlElement</code> instances of given type.
     * @param customSqlProvider the <code>CustomSqlProvider</code> instance.
     * @param type the type.
     * @return such elements.
     * @precondition sqlProvider != null
     * @precondition type != null
     */
    public SqlElement[] retrieveSqlElementsByType(
        final CustomSqlProvider customSqlProvider,
        final String type)
    {
        Collection t_cResult = new ArrayList();

        Collection t_cElements = customSqlProvider.getCollection();

        if  (t_cElements != null)
        {
            Iterator t_itElements = t_cElements.iterator();

            if  (t_itElements != null)
            {
                Object t_CurrentItem = null;

                while  (t_itElements.hasNext())
                {
                    t_CurrentItem = t_itElements.next();

                    if  (   (t_CurrentItem instanceof SqlElement)
                         && (type.equals(((SqlElement) t_CurrentItem).getType())))
                    {
                        t_cResult.add(t_CurrentItem);
                    }
                }
            }
        }

        return
            (SqlElement[]) t_cResult.toArray(EMPTY_SQLELEMENT_ARRAY);
    }

    /**
     * Retrieves all <code>SqlElement</code> instances associated to
     * given result id.
     * @param customSqlProvider the <code>CustomSqlProvider</code> instance.
     * @param resultId the result id.
     * @return such elements.
     * @precondition sqlProvider != null
     * @precondition resultId != null
     */
    public SqlElement[] retrieveSqlElementsByResultId(
        final CustomSqlProvider customSqlProvider,
        final String resultId)
    {
        Collection t_cResult = new ArrayList();

        Collection t_cElements = customSqlProvider.getCollection();

        if  (t_cElements != null)
        {
            Iterator t_itElements = t_cElements.iterator();

            if  (t_itElements != null)
            {
                Object t_CurrentItem = null;

                ResultRefElement t_ResultRef = null;

                while  (t_itElements.hasNext())
                {
                    t_CurrentItem = t_itElements.next();

                    if  (t_CurrentItem instanceof SqlElement)
                    {
                        t_ResultRef = ((SqlElement) t_CurrentItem).getResultRef();

                        if  (   (t_ResultRef != null)
                             && (resultId.equals(t_ResultRef.getId())))
                        {
                            t_cResult.add(t_CurrentItem);
                        }
                    }
                }
            }
        }

        return
            (SqlElement[]) t_cResult.toArray(EMPTY_SQLELEMENT_ARRAY);
    }

    /**
     * Retrieves all <code>ResultElement</code> instances of given type.
     * @param customSqlProvider the <code>CustomSqlProvider</code> instance.
     * @param type the type.
     * @return such elements.
     * @precondition sqlProvider != null
     * @precondition type != null
     */
    public ResultElement[] retrieveResultElementsByType(
        final CustomSqlProvider customSqlProvider,
        final String type)
    {
        Collection t_cResult = new ArrayList();

        SqlElement[] t_aSqlElements =
            retrieveSqlElementsByType(customSqlProvider, type);

        ResultElement t_CurrentElement = null;

        for  (int t_iIndex = 0; t_iIndex < t_aSqlElements.length; t_iIndex++)
        {
            t_CurrentElement =
                customSqlProvider.resolveReference(
                    t_aSqlElements[t_iIndex].getResultRef());

            if  (t_CurrentElement != null)
            {
                t_cResult.add(t_CurrentElement);
            }
        }

        return
            (ResultElement[]) t_cResult.toArray(EMPTY_RESULTELEMENT_ARRAY);
    }

    /**
     * Retrieves all <code>PropertyElement</code> instances associated to
     * given result element.
     * @param customSqlProvider the <code>CustomSqlProvider</code> instance.
     * @param resultElement the result element.
     * @return such elements.
     * @precondition sqlProvider != null
     * @precondition resultElement != null
     */
    public PropertyElement[] retrievePropertyElementsByResultId(
        final CustomSqlProvider customSqlProvider,
        final ResultElement resultElement)
    {
        Collection t_cResult = new ArrayList();

        Collection t_cPropertyRefs = resultElement.getPropertyRefs();

        if  (t_cPropertyRefs != null)
        {
            Iterator t_itPropertyRefs = t_cPropertyRefs.iterator();

            if  (t_itPropertyRefs != null)
            {
                while  (t_itPropertyRefs.hasNext())
                {
                    t_cResult.add(
                        customSqlProvider.resolveReference(
                            (PropertyRefElement) t_itPropertyRefs.next()));
                }
            }
        }

        return
            (PropertyElement[]) t_cResult.toArray(EMPTY_PROPERTYELEMENT_ARRAY);
    }
}
