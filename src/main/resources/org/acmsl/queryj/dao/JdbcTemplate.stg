//;-*- mode: antlr -*-
//
//                      QueryJ
//
//  Copyright (C) 2002-2007  ACM-SL
//                           chous@acm-sl.org
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU General Public
//  License as published by the Free Software Foundation; either
//  version 2 of the License, or any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  General Public License for more details.
//
//  You should have received a copy of the GNU General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//  Thanks to ACM S.L. for distributing this library under the GPL license.
//  Contact info: jose.sanleandro@acm-sl.com
//  Postal Address: c/Playa de Lagoa, 1
//                  Urb. Valdecabanas
//                  Boadilla del monte
//                  28660 Madrid
//                  Spain
//
//***************************************************************************
//
// Filename: JdbcTemplate.stg
//
// Author: Jose San Leandro Armendariz
//
// Description: Customizes JdbcTemplate to deal with proper connection
//              handling.
//
// Version: $Revision: 1769 $ ($Author: chous $ at $Date: 2007-04-23 10:14:02 +0200 (Mon, 23 Apr 2007) $)
//
// $Id: JdbcTemplate.stg 1769 2007-04-23 08:14:02Z chous $
//
group JdbcTemplate;

source(input) ::= <<
<!
  Generates a JdbcTemplate implementation.
  @param input.copyright_years the copyright's years.
  @param input.table_name the table name.
  @param input.package the package.
  @param input.dao_class_name the DAO class name.
  @param input.dao_factory_class_name the DAO factory class name.
  @param input.dao_implementation_class_name the DAO implementation class name.
  @params project_imports
  @params class
!>
<if(input.header)>
<input.header>
<else>
<java_header(
  years=input.copyright_years,
  description=
  [
    first_line_description(
      tableName=input.table_name,
      engineName=input.engine_name,
      engineVersion=input.engine_version),
    second_line_description(
      tableName=input.table_name,
      engineName=input.engine_name,
      engineVersion=input.engine_version)
  ],
  timestamp=input.timestamp)>
<endif>
// Generated by $Id: DAO.stg 1769 2007-04-23 08:14:02Z chous $

<package_declaration(
  packageNames=
  [
    input.base_package_name,
    typeInitMap.baseDAOSubpackageName,
    typeInitMap.rdbSubpackageName
  ])>

<project_imports(
  basePackageName=input.base_package_name,
  baseDAOSubpackageName=typeInitMap.baseDAOSubpackageName,
  rdbSubpackageName=typeInitMap.rdbSubpackageName,
  trName=input.tr_name_capitalized)>

/*
 * Importing Spring classes.
 */
import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.ConnectionCallback;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.PreparedStatementCallback;
import org.springframework.jdbc.core.PreparedStatementCreator;
import org.springframework.jdbc.core.PreparedStatementCreatorFactory;
import org.springframework.jdbc.core.PreparedStatementSetter;
import org.springframework.jdbc.core.ResultSetExtractor;
import org.springframework.jdbc.core.SqlParameter;
import org.springframework.jdbc.core.StatementCallback;
import org.springframework.jdbc.datasource.ConnectionHolder;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.jdbc.datasource.DataSourceUtils;
import org.springframework.jdbc.object.SqlQuery;
import org.springframework.jdbc.SQLWarningException;
import org.springframework.jdbc.support.JdbcUtils;
import org.springframework.jdbc.support.nativejdbc.NativeJdbcExtractor;
import org.springframework.jdbc.support.SQLExceptionTranslator;
import org.springframework.transaction.support.TransactionCallback;
import org.springframework.transaction.support.TransactionSynchronizationAdapter;
import org.springframework.transaction.support.TransactionSynchronizationManager;
import org.springframework.transaction.support.TransactionTemplate;
import org.springframework.transaction.TransactionException;
import org.springframework.transaction.TransactionStatus;
import org.springframework.jdbc.core.ParameterDisposer;
import org.springframework.jdbc.core.SqlProvider;

/*
 * Importing some JDK classes.
 */
import java.math.BigDecimal;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;
import java.sql.Types;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/*
 * Importing some JDK extension classes
 */
import javax.sql.DataSource;

/*
 * Importing Jakarta Commons Logging classes
 */
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

<class(input=input)>
>>

first_line_description(tableName, engineName, engineVersion) ::= <<
<!
  Generates a description for the generated file.
  @param tableName the table name.
  @param engineName the engine name.
  @param engineVersion the engine version.
!>
Creates the \<code>PreparedStatement\</code>
>>

second_line_description(tableName, engineName, engineVersion) ::= <<
<!
  Generates a description for the generated file.
  @param tableName the table name.
  @param engineName the engine name.
  @param engineVersion the engine version.
!>
required to perform any \<i>JDBC\</i> operation.
>>

project_imports(
  basePackageName,
  baseDAOSubpackageName,
  rdbSubpackageName,
  trName) ::= <<
<!
 Generates the project imports.
 @param basePackageName the base package name.
 @param baseDAOSubpackageName the base DAO subpackage name.
 @param rdbSubpackageName the rdb subpackage name.
 @param trName the table repository name.
!>
/*
 * Importing project classes.
 */
import <basePackageName>.<baseDAOSubpackageName>.<rdbSubpackageName>.<trName>DAOListener;
>>

class(input) ::= <<
<!
 Generates the class body.
 @param input.vo_name the value object name.
 @param input.engine_name the engine name.
 @param input.engine_version the engine version.
 @param input.timestamp the timestamp.
 @param input.custom_results the results for the custom queries.
 @param input.tr_name the table repository name.
!>
/**
 * <[
      first_line_description(
        tableName=input.table_name,
        engineName=input.engine_name,
        engineVersion=input.engine_version),
      second_line_description(
        tableName=input.table_name,
        engineName=input.engine_name,
        engineVersion=input.engine_version)
    ]:{line |<line>}; separator="\n * ">
 * @author \<a href="http://www.acm-sl.org/queryj"\>QueryJ\</a\>
 * @version <"$">Revision: $ (<"$">Author: $ at <"$">Date: $)
 * @since <input.timestamp>
 */
public class <input.tr_name_capitalized>JdbcTemplate
    extends  JdbcTemplate
{
    /**
     * The audit log category.
     */
    public static final String AUDITLOG_CATEGORY = "<input.tr_name>-queryj-auditlog";
    
    /**
     * Whether to enable auditlog or not.
     */
    private static boolean m__bEnableAuditLog = false;

    /**
     * The DAOListener instance.
     */
    private <input.tr_name_capitalized>DAOListener m__<input.tr_name_capitalized>DAOListener;

    /**
     * Construct a new JdbcTemplate for bean usage.
     * Note: The DataSource has to be set before using the instance.
     * This constructor can be used to prepare a JdbcTemplate via a BeanFactory,
     * typically setting the DataSource via setDataSource.
     * @see #setDataSource
     */
    public <input.tr_name_capitalized>JdbcTemplate(
        final <input.tr_name_capitalized>DAOListener daoListener)
    {
        immutableSetDAOListener(daoListener);
    }


    /**
     * Construct a new \<code><input.tr_name_capitalized>JdbcTemplate\</code>,
     * given a DataSource to obtain connections from.
     * Note: This will trigger eager initialization of the exception translator.
     * @param dataSource JDBC DataSource to obtain connections from
     * @param dao
     */
    public <input.tr_name_capitalized>JdbcTemplate(
        final DataSource dataSource,
        final <input.tr_name_capitalized>DAOListener daoListener)
    {
        super(dataSource);
        immutableSetDAOListener(daoListener);
    }

    /**
     * Specifies the DAO listener.
     * @param daoListener such listener.
     */
    protected final void immutableSetDAOListener(
        final <input.tr_name_capitalized>DAOListener daoListener)
    {
        m__<input.tr_name_capitalized>DAOListener = daoListener;
    }

    /**
     * Specifies the DAO listener.
     * @param daoListener such listener.
     */
    protected void setDAOListener(
        final <input.tr_name_capitalized>DAOListener daoListener)
    {
        immutableSetDAOListener(daoListener);
    }

    /**
     * Retrieves the DAO listener.
     * @return such instance.
     */
    protected <input.tr_name_capitalized>DAOListener getDAOListener()
    {
        return m__<input.tr_name_capitalized>DAOListener;
    }

    /**
     * Retrieves the data source.
     * @return such instance.
     */
    public synchronized DataSource getSynchronizedDataSource()
    {
        return getDataSource();
    }

    /**
     * Executes a operation, taking into account a proper connection handling.
     * @param action the \<code>ConnectionCallback\</code> instance.
     * @return the result of the operation.
     * @precondition action != null
     */
    public Object execute(final ConnectionCallback action)
        throws DataAccessException
    {
        Object result = null;

        synchronized (<input.tr_name_capitalized>JdbcTemplate.class)
        {
            result =
                execute(
                    action,
                    getDataSource(),
                    getDAOListener(),
                    getNativeJdbcExtractor(),
                    getExceptionTranslator());
        }

        return result;
    }

    /**
     * Executes a operation, taking into account a proper connection handling.
     * @param action the \<code>ConnectionCallback\</code> instance.
     * @param dataSource the \<code>DataSource\</code> instance.
     * @param daoListener the \<code><input.tr_name_capitalized>DAOListener\</code> instance.
     * @param nativeJdbcExtractor the native JDBC extractor.
     * @param exceptionTranslator the exception translator.
     * @return the result of the operation.
     * @precondition action != null
     * @precondition dataSource != null
     * @precondition nativeJdbcExtractor != null
     * @precondition exceptionTranslator != null
     */
    protected Object execute(
        final ConnectionCallback action,
        final DataSource dataSource,
        final <input.tr_name_capitalized>DAOListener daoListener,
        final NativeJdbcExtractor nativeJdbcExtractor,
        final SQLExceptionTranslator exceptionTranslator)
      throws DataAccessException
    {
        Object result = null;

        Connection t_Connection = null;

        boolean t_bCloseConnection = false;

        DataSource t_DataSource = dataSource;

        if  (!(dataSource instanceof <input.tr_name_capitalized>ThreadAwareDataSourceWrapper))
        {
            t_DataSource = new <input.tr_name_capitalized>ThreadAwareDataSourceWrapper(dataSource);
        }

        try
        {
            ConnectionHolder t_ConnectionHolder =
                (ConnectionHolder)
                    TransactionSynchronizationManager.getResource(
                        t_DataSource);

            if  (t_ConnectionHolder != null)
            {
                t_Connection = t_ConnectionHolder.getConnection();
            }
            else
            {
                t_Connection = t_DataSource.getConnection();
                t_bCloseConnection = true;
            }

            if  (daoListener != null)
            {
                daoListener.connectionRetrieved(getSql(action));
            }

            if  (   (TransactionSynchronizationManager
                         .isSynchronizationActive())
                 && (t_bCloseConnection))
            {
                t_ConnectionHolder = new ConnectionHolder(t_Connection);

                TransactionSynchronizationManager.bindResource(
                    t_DataSource, t_ConnectionHolder);

                TransactionSynchronizationManager.registerSynchronization(
                    new ConnectionSynchronization(
                        t_ConnectionHolder, t_DataSource));
            }

            Connection t_ConnectionToUse = t_Connection;

            if  (nativeJdbcExtractor != null)
            {
                t_ConnectionToUse =
                    nativeJdbcExtractor.getNativeConnection(t_Connection);
            }

            result = action.doInConnection(t_ConnectionToUse);
        }
        catch  (final SQLException sqlException)
        {
            throw
                exceptionTranslator.translate(
                    "executing ConnectionCallback",
                    getSql(action),
                    sqlException);
        }
        finally
        {
            if  (   (t_bCloseConnection)
                 && (t_Connection != null))
            {
                try
                {
                    t_Connection.close();
                }
                catch  (final SQLException sqlException)
                {
                    LogFactory.getLog(<input.tr_name_capitalized>JdbcTemplate.class).info(
                        "Could not close connection",
                        sqlException);
                }
            }

            if  (daoListener != null)
            {
                daoListener.connectionReleased(getSql(action));
            }
        }

        return result;
    }

    /**
     * Executes a operation, taking into account a proper connection handling.
     * @param action the \<code>StatementCallback\</code> instance.
     * @return the result of the operation.
     * @precondition action != null
     */
    public Object execute(final StatementCallback action)
        throws DataAccessException
    {
        return
            execute(
                action,
                getDataSource(),
                getDAOListener(),
                getNativeJdbcExtractor(),
                getExceptionTranslator());
    }

    /**
     * Executes a operation, taking into account a proper connection handling.
     * @param action the \<code>StatementCallback\</code> instance.
     * @param dataSource the \<code>DataSource\</code> instance.
     * @param daoListener the \<code><input.tr_name_capitalized>DAOListener\</code> instance.
     * @param nativeJdbcExtractor the native JDBC extractor.
     * @param exceptionTranslator the exception translator.
     * @return the result of the operation.
     * @precondition action != null
     * @precondition dataSource != null
     * @precondition nativeJdbcExtractor != null
     * @precondition exceptionTranslator != null
     */
    protected Object execute(
        final StatementCallback action,
        final DataSource dataSource,
        final <input.tr_name_capitalized>DAOListener daoListener,
        final NativeJdbcExtractor nativeJdbcExtractor,
        final SQLExceptionTranslator exceptionTranslator)
      throws DataAccessException
    {
        Object result = null;

        Connection t_Connection = null;

        boolean t_bCloseConnection = false;

        Statement t_Statement = null;

        DataSource t_DataSource = dataSource;

        if  (!(dataSource instanceof <input.tr_name_capitalized>ThreadAwareDataSourceWrapper))
        {
            t_DataSource = new <input.tr_name_capitalized>ThreadAwareDataSourceWrapper(dataSource);
        }

        try
        {
            ConnectionHolder t_ConnectionHolder =
                (ConnectionHolder)
                    TransactionSynchronizationManager.getResource(
                        t_DataSource);

            if  (t_ConnectionHolder != null)
            {
                t_Connection = t_ConnectionHolder.getConnection();
            }
            else
            {
                t_Connection = t_DataSource.getConnection();
                t_bCloseConnection = true;
            }

            if  (daoListener != null)
            {
                daoListener.connectionRetrieved(getSql(action));
            }

            if  (   (TransactionSynchronizationManager
                         .isSynchronizationActive())
                 && (t_bCloseConnection))
            {
                // use same Connection for further JDBC actions within the transaction
                // thread object will get removed by synchronization at transaction completion
                t_ConnectionHolder = new ConnectionHolder(t_Connection);

                TransactionSynchronizationManager.bindResource(
                    t_DataSource, t_ConnectionHolder);

                TransactionSynchronizationManager.registerSynchronization(
                    new ConnectionSynchronization(
                        t_ConnectionHolder, t_DataSource));
            }

            Connection t_ConnectionToUse = t_Connection;

            if  (   (nativeJdbcExtractor != null)
                 && (nativeJdbcExtractor
                         .isNativeConnectionNecessaryForNativeStatements()))
            {
                t_ConnectionToUse =
                    nativeJdbcExtractor.getNativeConnection(t_Connection);
            }

            t_Statement = t_ConnectionToUse.createStatement();

            DataSourceUtils.applyTransactionTimeout(
                t_Statement, t_DataSource);
            
            Statement t_StatementToUse = t_Statement;

            if  (nativeJdbcExtractor != null)
            {
                t_StatementToUse =
                    nativeJdbcExtractor.getNativeStatement(t_Statement);
            }

            result = action.doInStatement(t_StatementToUse);

            SQLWarning t_Warning = t_Statement.getWarnings();

            throwExceptionOnWarningIfNotIgnoringWarnings(t_Warning);
        }
        catch (final SQLException sqlException)
        {
            throw exceptionTranslator.translate(
                "executing StatementCallback", getSql(action), sqlException);
        }
        finally
        {
            JdbcUtils.closeStatement(t_Statement);

            if  (   (t_bCloseConnection)
                 && (t_Connection != null))
            {
                try
                {
                    t_Connection.close();
                }
                catch  (final SQLException sqlException)
                {
                    LogFactory.getLog(<input.tr_name_capitalized>JdbcTemplate.class).info(
                        "Could not close connection",
                        sqlException);
                }
            }

            if  (daoListener != null)
            {
                daoListener.connectionReleased(getSql(action));
            }
        }

        return result;
    }

    /**
     * Executes a operation, taking into account a proper connection handling.
     * @param psc the \<code>preparedStatementCreator\</code> instance.
     * @param action the \<code>PreparedStatementCallback\</code> instance.
     * @return the result of the operation.
     * @precondition action != null
     */
    public Object execute(
        final PreparedStatementCreator preparedStatementCreator,
        final PreparedStatementCallback action)
      throws DataAccessException
    {
        return
            execute(
                preparedStatementCreator,
                action,
                getDataSource(),
                getDAOListener(),
                getNativeJdbcExtractor(),
                getExceptionTranslator());
    }

    /**
     * Executes a operation, taking into account a proper connection handling.
     * @param preparedStatementCreator the \<code>PreparedStatementCreator\</code>
     * instance.
     * @param action the \<code>PreparedStatementCallback\</code> instance.
     * @param dataSource the \<code>DataSource\</code> instance.
     * @param daoListener the \<code><input.tr_name_capitalized>DAOListener\</code> instance.
     * @param nativeJdbcExtractor the native JDBC extractor.
     * @param exceptionTranslator the exception translator.
     * @return the result of the operation.
     * @precondition preparedStatementCreator != null
     * @precondition action != null
     * @precondition dataSource != null
     * @precondition nativeJdbcExtractor != null
     * @precondition exceptionTranslator != null
     */
    protected Object execute(
        final PreparedStatementCreator preparedStatementCreator,
        final PreparedStatementCallback action,
        final DataSource dataSource,
        final <input.tr_name_capitalized>DAOListener daoListener,
        final NativeJdbcExtractor nativeJdbcExtractor,
        final SQLExceptionTranslator exceptionTranslator)
      throws DataAccessException
    {
        Object result = null;

        Connection t_Connection = null;

        boolean t_bCloseConnection = false;

        PreparedStatement t_PreparedStatement = null;

        DataSource t_DataSource = dataSource;

        if  (!(dataSource instanceof <input.tr_name_capitalized>ThreadAwareDataSourceWrapper))
        {
            t_DataSource = new <input.tr_name_capitalized>ThreadAwareDataSourceWrapper(dataSource);
        }

        try
        {
            ConnectionHolder t_ConnectionHolder =
                (ConnectionHolder)
                    TransactionSynchronizationManager.getResource(
                        t_DataSource);

            if  (t_ConnectionHolder != null)
            {
                t_Connection = t_ConnectionHolder.getConnection();
            }
            else
            {
                t_Connection = t_DataSource.getConnection();
                t_bCloseConnection = true;
            }

            if  (daoListener != null)
            {
                daoListener.connectionRetrieved(getSql(action));
            }

            if  (   (TransactionSynchronizationManager
                         .isSynchronizationActive())
                 && (t_bCloseConnection))
            {
                // use same Connection for further JDBC actions within the transaction
                // thread object will get removed by synchronization at transaction completion
                t_ConnectionHolder = new ConnectionHolder(t_Connection);

                TransactionSynchronizationManager.bindResource(
                    t_DataSource, t_ConnectionHolder);

                TransactionSynchronizationManager.registerSynchronization(
                    new ConnectionSynchronization(
                        t_ConnectionHolder, t_DataSource));
            }

            Connection t_ConnectionToUse = t_Connection;

            if  (   (nativeJdbcExtractor != null)
                 && (nativeJdbcExtractor
                         .isNativeConnectionNecessaryForNativePreparedStatements()))
            {
                t_ConnectionToUse =
                    nativeJdbcExtractor.getNativeConnection(t_Connection);
            }

            t_PreparedStatement =
                preparedStatementCreator.createPreparedStatement(
                    t_ConnectionToUse);

            if  (daoListener != null)
            {
                daoListener.statementCreated(
                    getSql(action), preparedStatementCreator);
            }

            DataSourceUtils.applyTransactionTimeout(
                t_PreparedStatement, t_DataSource);
            
            PreparedStatement t_PreparedStatementToUse =
                t_PreparedStatement;

            if  (nativeJdbcExtractor != null)
            {
                t_PreparedStatementToUse =
                    nativeJdbcExtractor.getNativePreparedStatement(
                        t_PreparedStatement);
            }

            result = action.doInPreparedStatement(t_PreparedStatementToUse);

            SQLWarning t_Warning = t_PreparedStatement.getWarnings();
            
            throwExceptionOnWarningIfNotIgnoringWarnings(t_Warning);
        }
        catch  (final SQLException sqlException)
        {
            throw
                exceptionTranslator.translate(
                      "executing PreparedStatementCallback ["
                    + preparedStatementCreator + "]",
                    getSql(preparedStatementCreator),
                    sqlException);
        }
        finally
        {
            if  (preparedStatementCreator instanceof ParameterDisposer)
            {
                ((ParameterDisposer) preparedStatementCreator)
                    .cleanupParameters();
            }

            JdbcUtils.closeStatement(t_PreparedStatement);

            if  (daoListener != null)
            {
                daoListener.statementReleased(
                    getSql(action), preparedStatementCreator);
            }

            if  (   (t_bCloseConnection)
                 && (t_Connection != null))
            {
                try
                {
                    t_Connection.close();
                }
                catch  (final SQLException sqlException)
                {
                    LogFactory.getLog(<input.tr_name_capitalized>JdbcTemplate.class).info(
                        "Could not close connection",
                        sqlException);
                }
            }

            if  (daoListener != null)
            {
                daoListener.connectionReleased(getSql(action));
            }
        }

        return result;
    }

    /**
     * Determine SQL from potential provider object.
     * @param sqlProvider object that's potentially a SqlProvider
     * @return the SQL string, or null
     * @see SqlProvider
     */
    protected String getSql(final Object sqlProvider)
    {
        String result = null;

        if  (sqlProvider instanceof SqlProvider)
        {
            result = ((SqlProvider) sqlProvider).getSql();
        }

        return result;
    }

    /**
     * Throw an SQLWarningException if we're not ignoring warnings.
     * @param warning warning from current statement. May be null,
     * in which case this method does nothing.
     */
    protected void throwExceptionOnWarningIfNotIgnoringWarnings(final SQLWarning warning)
        throws SQLWarningException
    {
        throwExceptionOnWarningIfNotIgnoringWarnings(warning, getIgnoreWarnings());
    }

    /**
     * Throw an SQLWarningException if we're not ignoring warnings.
     * @param warning warning from current statement. May be null,
     * in which case this method does nothing.
     * @param ignoreWarnings whether to ignore warnings.
     */
    protected void throwExceptionOnWarningIfNotIgnoringWarnings(
        final SQLWarning warning, final boolean ignoreWarnings)
      throws SQLWarningException
    {
        if  (   (warning != null)
             && (!ignoreWarnings))
        {
            throw new SQLWarningException("Warning not ignored", warning);
        }
    }

    /**
     * Callback for resource cleanup at the end of a non-native-JDBC transaction
     * (e.g. when participating in a JTA transaction).
     */
    private static class ConnectionSynchronization 
        extends TransactionSynchronizationAdapter
    {
        private final ConnectionHolder connectionHolder;

        private final DataSource dataSource;

        private ConnectionSynchronization(
            final ConnectionHolder connectionHolder, DataSource dataSource)
        {
            this.connectionHolder = connectionHolder;
            this.dataSource = dataSource;
        }

        public void suspend()
        {
            TransactionSynchronizationManager.unbindResource(
                this.dataSource);
        }

        public void resume()
        {
            TransactionSynchronizationManager.bindResource(
                this.dataSource, this.connectionHolder);
        }

        public void beforeCompletion()
        {
            TransactionSynchronizationManager.unbindResource(this.dataSource);

            DataSourceUtils.closeConnectionIfNecessary(
                this.connectionHolder.getConnection(), this.dataSource);
        }
    }

    /**
     * Audits given sql.
     * @param sql the original sql.
     * @return the auditted sql.
     */
    protected static String auditSql(final String sql)
    {
        StringBuffer result = new StringBuffer();
    
        Map map = <input.tr_name_capitalized>ThreadLocalBag.getThreadBag();

        boolean enableAuditLog = getEnableAuditLog();
        
        if  (   (enableAuditLog)
             && (map != null))
        {
            String user = (String) map.get(<input.tr_name_capitalized>ThreadLocalBag.PRINCIPAL);
            String ip = (String) map.get(<input.tr_name_capitalized>ThreadLocalBag.REMOTE_IP);
    
            if  (   (user != null)
                 || (ip != null))
            {
                result.append("/* ");
            }
    
            if  (user != null)
            {
                result.append(user);
                result.append("|");
            }
    
            if  (ip != null)
            {
                result.append(ip);
            }
    
            if  (   (user != null)
                 || (ip != null))
            {
                result.append(" */");
            }
        }
    
        result.append(sql);

        if  (enableAuditLog)
        {
            auditLog();
        }

        return result.toString();
    }
    
    /**
     * Performs an audit log.
     */
    protected static void auditLog()
    {
        Log log = LogFactory.getLog(AUDITLOG_CATEGORY);
        Map map = <input.tr_name_capitalized>ThreadLocalBag.getThreadBag();
    
        if  (   (map != null)
             && (getEnableAuditLog())
             && (log.isInfoEnabled())
             && (map.size() > 0))
        {
            log.info(map.toString());
        }
    }

    /**
     * Specifies whether to enable auditlog or not.
     * @param flag such flag.
     */
    protected static final void immutableSetEnableAuditLog(final boolean flag)
    {
        m__bEnableAuditLog = flag;
    }

    /**
     * Specifies whether to enable auditlog or not.
     * @param flag such flag.
     */
    public static void setEnableAuditLog(final boolean flag)
    {
        immutableSetEnableAuditLog(flag);
    }

    /**
     * Retrieves whether the auditlog is enabled.
     * @return such information.
     */
    protected static final boolean immutableGetEnableAuditLog()
    {
        return m__bEnableAuditLog;
    }

    /**
     * Retrieves whether the auditlog is enabled.
     * @return such information.
     */
    public static boolean getEnableAuditLog()
    {
        return immutableGetEnableAuditLog();
    }
}
>>
