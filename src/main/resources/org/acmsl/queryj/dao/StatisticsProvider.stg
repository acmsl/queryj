//;-*- mode: antlr -*-
//
//                      QueryJ
//
//  Copyright (C) 2002-2007  ACM-SL
//                           chous@acm-sl.org
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU General Public
//  License as published by the Free Software Foundation; either
//  version 2 of the License, or any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  General Public License for more details.
//
//  You should have received a copy of the GNU General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//  Thanks to ACM S.L. for distributing this library under the GPL license.
//  Contact info: jose.sanleandro@acm-sl.com
//  Postal Address: c/Playa de Lagoa, 1
//                  Urb. Valdecabanas
//                  Boadilla del monte
//                  28660 Madrid
//                  Spain
//
//***************************************************************************
//
// Filename: StatisticsProvider.stg
//
// Author: Jose San Leandro Armendariz
//
// Description: Generates StatisticsProvider sources.
//
// Version: $Revision: 1769 $ ($Author: chous $ at $Date: 2007-04-23 10:14:02 +0200 (Mon, 23 Apr 2007) $)
//
// $Id: StatisticsProvider.stg 1769 2007-04-23 08:14:02Z chous $
//
group StatisticsProvider;

source(input) ::= <<
<!
  Generates a StatisticsProvider source.
  @param input.copyright_years the copyright's years.
  @param input.package the package.
  @params class
!>
<if(input.header)>
<input.header>
<else>
<java_header(
  years=input.copyright_years,
  description=
  [
    first_line_description()
  ],
  timestamp=input.timestamp)>
<endif>
// Generated by $Id: DAO.stg 1769 2007-04-23 08:14:02Z chous $

<package_declaration(
  packageNames=
  [
    input.base_package_name,
    typeInitMap.baseDAOSubpackageName,
    typeInitMap.rdbSubpackageName
  ])>

/*
 * Importing some Spring classes.
 */
import org.springframework.jdbc.core.ConnectionCallback;
import org.springframework.jdbc.core.StatementCallback;
import org.springframework.jdbc.core.PreparedStatementCallback;
import org.springframework.jdbc.core.PreparedStatementCreator;

/*
 * Importing some JDK classes.
 */
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

<class(input=input)>
>>

first_line_description() ::= <<
<!
  Generates a description for the generated file.
!>
Provides statistics about QueryJ-generated persistence layer.
>>

class(input) ::= <<
<!
 Generates the class body.
 @param input.timestamp the timestamp.
 @param input.tr_name the table repository name.
!>
/**
 * <[
      first_line_description()
    ]:{line |<line>}; separator="\n * ">
 * @author \<a href="http://www.acm-sl.org/queryj"\>QueryJ\</a\>
 * @version <"$">Revision: $ (<"$">Author: $ at <"$">Date: $)
 * @since <input.timestamp>
 */
public class <input.tr_name_capitalized>StatisticsProvider
{
    /**
     * The list storing threads for which there're statistics.
     */
    private static final List THREAD_LIST =
        new ArrayList();

    /**
     * The map storing per-thread statistics.
     */
    private static final Map THREAD_MAP =
        new <input.tr_name_capitalized>ThreadLocalBag.TimestampMapDecorator(
            new <input.tr_name_capitalized>ThreadLocalBag.KeyBoundedMapDecorator(
                new HashMap(), 100));

    /**
     * The key to store the SQL.
     */
    public static final String SQL_KEY = "sql";

    /**
     * The key to store the SQL parameters.
     */
    public static final String SQL_PARAMETERS_KEY = "sql-paramters";

    /**
     * Singleton implemented to avoid double-check locking.
     */
    protected static final class <input.tr_name_capitalized>StatisticsProviderSingletonContainer
    {
        /**
         * The actual singleton.
         */
        public static final <input.tr_name_capitalized>StatisticsProvider SINGLETON =
            new <input.tr_name_capitalized>StatisticsProvider();
    }

    /**
     * Retrieves the singleton instance.
     * @return such instance.
     */
    public static <input.tr_name_capitalized>StatisticsProvider getInstance()
    {
        return <input.tr_name_capitalized>StatisticsProviderSingletonContainer.SINGLETON;
    }

    /**
     * Annotates an operation on the persistence
     * layer takes place.
     * @param sql the sql sentence.
     * @param parameters the sql parameters.
     */
    public void annotatePreparedStatementExecuted(
        final String sql, final Object[] parameters)
    {
        Map values = new HashMap();

        values.put(SQL_KEY, sql);
        values.put(SQL_PARAMETERS_KEY, parameters);

        THREAD_MAP.put(
            buildStatementKey(Thread.currentThread()), values);
    }

    /**
     * Builds a statement key for given thread.
     * @param thread the thread.
     * @return such key.
     */
    protected Object buildStatementKey(final Thread thread)
    {
        return "statement-thread-key::" + thread.hashCode();
    }

    /**
     * Annotates a connection is retrieved.
     * @param sql the SQL sentence.
     */
    public void annotateConnectionRetrieved(final String sql)
    {
        THREAD_MAP.put(
            buildConnectionKey(Thread.currentThread()), sql);
    }

    /**
     * Annotates a connection is released.
     * @param sql the SQL sentence.
     */
    public void annotateConnectionReleased(final String sql)
    {
        THREAD_MAP.remove(
            buildConnectionKey(Thread.currentThread()));
    }

    /**
     * Builds a connection key for given thread.
     * @param thread the thread.
     * @return such key.
     */
    protected Object buildConnectionKey(final Thread thread)
    {
        return "connection-thread-key::" + thread.hashCode();
    }

    /**
     * Annotates a statement is created.
     * @param sql the SQL sentence.
     * @param preparedStatementCreator the statement creator.
     */
    public void annotateStatementCreated(
        final String sql,
        final PreparedStatementCreator preparedStatementCreator)
    {
        THREAD_MAP.put(
            buildStatementKey(Thread.currentThread()), sql);
    }

    /**
     * Annotates a statement is prepared.
     * @param sql the sql.
     */
    public void annotateStatementPrepared(final String sql)
    {
        THREAD_MAP.put(
            buildStatementKey(Thread.currentThread()), sql);
    }

    /**
     * Annotates a statement is released.
     * @param sql the SQL sentence.
     * @param preparedStatementCreator the statement creator.
     */
    public void annotateStatementReleased(
        final String sql,
        final PreparedStatementCreator preparedStatementCreator)
    {
        THREAD_MAP.remove(
            buildStatementKey(Thread.currentThread()));
    }

    /**
     * Annotates a result-set moves forward one row.
     * @param resultSetExtractor the ResultSet extractor.
     */
    public void annotateResultSetMovedForward(
        final <input.tr_name_capitalized>ResultSetExtractor resultSetExtractor)
    {
        Object key = buildResultSetKey(Thread.currentThread());

        Integer rowsRetrieved = (Integer) THREAD_MAP.get(key);

        if  (rowsRetrieved == null)
        {
            rowsRetrieved = new Integer(0);
        }

        THREAD_MAP.put(key, new Integer(rowsRetrieved.intValue() + 1));
    }

    /**
     * Annotates a result-set is closed.
     * @param resultSetExtractor the ResultSet extractor.
     */
    public void annotateResultSetClosed(
        final <input.tr_name_capitalized>ResultSetExtractor resultSetExtractor)
    {
//        THREAD_MAP.remove(
//            buildResultSetKey(Thread.currentThread()));
    }

    /**
     * Builds a resultset key for given thread.
     * @param thread the thread.
     * @return such key.
     */
    protected Object buildResultSetKey(final Thread thread)
    {
        return "resultset-thread-key::" + thread.hashCode();
    }

}
>>
