//;-*- mode: antlr -*-
//
//                      QueryJ
//
//  Copyright (C) 2002-2007  ACM-SL
//                           chous@acm-sl.org
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU General Public
//  License as published by the Free Software Foundation; either
//  version 2 of the License, or any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  General Public License for more details.
//
//  You should have received a copy of the GNU General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//  Thanks to ACM S.L. for distributing this library under the GPL license.
//  Contact info: jose.sanleandro@acm-sl.com
//  Postal Address: c/Playa de Lagoa, 1
//                  Urb. Valdecabanas
//                  Boadilla del monte
//                  28660 Madrid
//                  Spain
//
//***************************************************************************
//
// Filename: StatisticsProvider.stg
//
// Author: Jose San Leandro Armendariz
//
// Description: Generates StatisticsProvider sources.
//
// Version: $Revision$ ($Author$ at $Date$)
//
// $Id$
//
group StatisticsProvider;

source(input) ::= <<
<!
  Generates a StatisticsProvider source.
  @param input.copyright_years the copyright's years.
  @param input.package the package.
  @params class
!>
<if(input.header)>
<input.header>
<else>
<java_header(
  years=input.copyright_years,
  description=
  [
    first_line_description()
  ],
  timestamp=input.timestamp)>
<endif>
// Generated by $Id$

<package_declaration(
  packageNames=
  [
    input.base_package_name,
    typeInitMap.baseDAOSubpackageName,
    typeInitMap.rdbSubpackageName
  ])>

/*
 * Importing some Spring classes.
 */
import org.springframework.jdbc.core.ConnectionCallback;
import org.springframework.jdbc.core.StatementCallback;
import org.springframework.jdbc.core.PreparedStatementCallback;
import org.springframework.jdbc.core.PreparedStatementCreator;

/*
 * Importing some JDK classes.
 */
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

<class(input=input)>
>>

first_line_description() ::= <<
<!
  Generates a description for the generated file.
!>
Provides statistics about QueryJ-generated persistence layer.
>>

class(input) ::= <<
<!
 Generates the class body.
 @param input.timestamp the timestamp.
 @param input.tr_name the table repository name.
!>
/**
 * <[
      first_line_description()
    ]:{line |<line>}; separator="\n * ">
 * @author \<a href="http://www.acm-sl.org/queryj"\>QueryJ\</a\>
 * @version <"$">Revision: $ (<"$">Author: $ at <"$">Date: $)
 * @since <input.timestamp>
 */
public class <input.tr_name_capitalized>StatisticsProvider
{
    /**
     * The list storing threads for which there're statistics.
     */
    private static final List THREAD_LIST =
        new ArrayList();

    /**
     * The map storing per-thread statistics.
     */
    private static final Map THREAD_MAP =
        new <input.tr_name_capitalized>ThreadLocalBag.TimestampMapDecorator(
            new <input.tr_name_capitalized>ThreadLocalBag.KeyBoundedMapDecorator(
                new HashMap(), 100));

    /**
     * The key to store the SQL.
     */
    public static final String SQL_KEY = "sql";

    /**
     * The key to store the SQL parameters.
     */
    public static final String SQL_PARAMETERS_KEY = "sql-parameters";

    /**
     * Singleton implemented to avoid double-check locking.
     */
    protected static final class <input.tr_name_capitalized>StatisticsProviderSingletonContainer
    {
        /**
         * The actual singleton.
         */
        public static final <input.tr_name_capitalized>StatisticsProvider SINGLETON =
            new <input.tr_name_capitalized>StatisticsProvider();
    }

    /**
     * Retrieves the singleton instance.
     * @return such instance.
     */
    public static <input.tr_name_capitalized>StatisticsProvider getInstance()
    {
        return <input.tr_name_capitalized>StatisticsProviderSingletonContainer.SINGLETON;
    }

    /**
     * Annotates a connection is retrieved.
     * @param sql the SQL sentence.
     */
    public void annotateConnectionRetrieved(final String sql)
    {
        synchronized(THREAD_MAP)
        {
            THREAD_MAP.put(
                buildConnectionKey(Thread.currentThread()), sql);

            Object connectionCountKey = buildConnectionCountKey();

            Integer connectionCount =
                (Integer) THREAD_MAP.get(connectionCountKey);

            if  (connectionCount == null)
            {
                connectionCount = new Integer(1);
            }
            else
            {
                connectionCount = new Integer(connectionCount.intValue() + 1);
            }

            THREAD_MAP.put(connectionCountKey, connectionCount);
        }
    }

    /**
     * Builds the last-connection-key key.
     * @return such key.
     */
    protected Object buildLastConnectionSqlKey()
    {
        return "::last-connection-sql-key::";
    }

    /**
     * Retrieves the values associated to the last annotated connection.
     * @return such information.
     */
    public String getLastConnectionSql()
    {
        String result = null;

        synchronized (THREAD_MAP)
        {
            result =
                (String)
                    THREAD_MAP.get(
                        buildConnectionKey(Thread.currentThread()));

            if  (result == null)
            {
                result =
                    (String)
                        THREAD_MAP.get(buildLastConnectionSqlKey());
            }
        }

        return result;
    }

    /**
     * Retrieves the values associated to the last annotated connection.
     * @return such information.
     */
    public int getConnectionCount()
    {
        Integer result = null;

        synchronized (THREAD_MAP)
        {
            result = (Integer) THREAD_MAP.get(buildConnectionCountKey());
        }

        return (result == null) ? 0 : result.intValue();
    }

    /**
     * Annotates a connection is released.
     * @param sql the SQL sentence.
     */
    public void annotateConnectionReleased(final String sql)
    {
        synchronized (THREAD_MAP)
        {
            String lastConnectionSql =
                (String) THREAD_MAP.remove(buildConnectionKey(Thread.currentThread()));

            if  (lastConnectionSql != null)
            {
                THREAD_MAP.put(
                    buildLastConnectionSqlKey(),
                    lastConnectionSql);
            }

            Object connectionCountKey = buildConnectionCountKey();

            Integer connectionCount =
                (Integer) THREAD_MAP.get(connectionCountKey);

            if  (connectionCount == null)
            {
                connectionCount = new Integer(0);
            }
            else
            {
                connectionCount =
                    new Integer(connectionCount.intValue() - 1);
            }

            THREAD_MAP.put(connectionCountKey, connectionCount);
        }
    }

    /**
     * Builds a connection key for given thread.
     * @param thread the thread.
     * @return such key.
     */
    protected Object buildConnectionKey(final Thread thread)
    {
        return "connection-thread-key::" + thread.hashCode();
    }

    /**
     * Builds a connection count key.
     * @return such key.
     */
    protected Object buildConnectionCountKey()
    {
        return "::connection-count-key::";
    }

    /**
     * Annotates an operation on the persistence
     * layer takes place.
     * @param sql the sql sentence.
     * @param parameters the sql parameters.
     */
    public void annotatePreparedStatementExecuted(
        final String sql, final Object[] parameters)
    {
        synchronized (THREAD_MAP)
        {
            Map values = new HashMap();

            values.put(SQL_KEY, sql);
            values.put(SQL_PARAMETERS_KEY, parameters);

            THREAD_MAP.put(
                buildPreparedStatementKey(
                    Thread.currentThread()), values);

            Object statementCountKey = buildStatementCountKey();

            Integer statementCount =
                (Integer) THREAD_MAP.get(statementCountKey);

            if  (statementCount == null)
            {
                statementCount = new Integer(1);
            }
            else
            {
                statementCount =
                    new Integer(statementCount.intValue() + 1);
            }

            THREAD_MAP.put(statementCountKey, statementCount);
        }
    }

    /**
     * Retrieves the values associated to the last annotated statement.
     * @return such information.
     */
    public Map getLastPreparedStatementData()
    {
        Map result = null;

        synchronized (THREAD_MAP)
        {
            result =
                (Map)
                    THREAD_MAP.get(
                        buildPreparedStatementKey(
                            Thread.currentThread()));
        }

        return result;
    }

    /**
     * Builds a statement key for given thread.
     * @param thread the thread.
     * @return such key.
     */
    protected Object buildPreparedStatementKey(final Thread thread)
    {
        return "prepared-statement-thread-key::" + thread.hashCode();
    }

    /**
     * Builds a statement key for given thread.
     * @param thread the thread.
     * @return such key.
     */
    protected Object buildStatementKey(final Thread thread)
    {
        return "statement-thread-key::" + thread.hashCode();
    }

    /**
     * Builds the last-statement-sql key.
     * @return such key.
     */
    protected Object buildLastStatementSqlKey()
    {
        return "::last-statement-sql-key::";
    }

    /**
     * Retrieves the values associated to the last annotated statement.
     * @return such information.
     */
    public String getLastStatementSql()
    {
        String result = null;

        synchronized (THREAD_MAP)
        {
            result =
                (String)
                    THREAD_MAP.get(
                        buildStatementKey(Thread.currentThread()));

            if  (result == null)
            {
                result =
                    (String)
                        THREAD_MAP.get(buildLastStatementSqlKey());
            }
        }

        return result;
    }

    /**
     * Builds a statement count key.
     * @return such key.
     */
    protected Object buildStatementCountKey()
    {
        return "::statement-count-key::";
    }

    /**
     * Retrieves the values associated to the last annotated statement.
     * @return such information.
     */
    public int getStatementCount()
    {
        Integer result = null;

        synchronized  (THREAD_MAP)
        {
            result =
                (Integer) THREAD_MAP.get(buildStatementCountKey());
        }

        return (result == null) ? 0 : result.intValue();
    }

    /**
     * Annotates a statement is created.
     * @param sql the SQL sentence.
     * @param preparedStatementCreator the statement creator.
     */
    public void annotateStatementCreated(
        final String sql,
        final PreparedStatementCreator preparedStatementCreator)
    {
        synchronized (THREAD_MAP)
        {
            THREAD_MAP.put(
                buildStatementKey(Thread.currentThread()), sql);

            Object statementCountKey = buildStatementCountKey();

            Integer statementCount =
                (Integer) THREAD_MAP.get(statementCountKey);

            if  (statementCount == null)
            {
                statementCount = new Integer(1);
            }
            else
            {
                statementCount =
                    new Integer(statementCount.intValue() + 1);
            }

            THREAD_MAP.put(statementCountKey, statementCount);
        }
    }

    /**
     * Annotates a statement is prepared.
     * @param sql the sql.
     */
    public void annotateStatementPrepared(final String sql)
    {
        synchronized  (THREAD_MAP)
        {
            THREAD_MAP.put(
                buildStatementKey(Thread.currentThread()), sql);

            Object statementCountKey = buildStatementCountKey();

            Integer statementCount =
                (Integer) THREAD_MAP.get(statementCountKey);

            if  (statementCount == null)
            {
                statementCount = new Integer(1);
            }
            else
            {
                statementCount =
                    new Integer(statementCount.intValue() + 1);
            }

            THREAD_MAP.put(statementCountKey, statementCount);
        }
    }

    /**
     * Annotates a statement is released.
     * @param sql the SQL sentence.
     * @param preparedStatementCreator the statement creator.
     */
    public void annotateStatementReleased(
        final String sql,
        final PreparedStatementCreator preparedStatementCreator)
    {
        synchronized  (THREAD_MAP)
        {
            String lastStatementSql =
                (String)
                    THREAD_MAP.remove(
                        buildStatementKey(Thread.currentThread()));

            if  (lastStatementSql != null)
            {
                THREAD_MAP.put(
                    buildLastStatementSqlKey(), lastStatementSql);
            }

            Object statementCountKey = buildStatementCountKey();

            Integer statementCount =
                (Integer) THREAD_MAP.get(statementCountKey);

            if  (statementCount == null)
            {
                statementCount = new Integer(0);
            }
            else
            {
                statementCount = new Integer(statementCount.intValue() - 1);
            }

            THREAD_MAP.put(statementCountKey, statementCount);
        }
    }

    /**
     * Annotates a result-set moves forward one row.
     * @param resultSetExtractor the ResultSet extractor.
     */
    public void annotateResultSetMovedForward(
        final <input.tr_name_capitalized>ResultSetExtractor resultSetExtractor)
    {
        synchronized  (THREAD_MAP)
        {
            Object key = buildResultSetKey(Thread.currentThread());

            Integer rowsRetrieved = (Integer) THREAD_MAP.get(key);

            if  (rowsRetrieved == null)
            {
                rowsRetrieved = new Integer(0);

                Object resultSetCountKey = buildResultSetCountKey();

                Integer resultSetCount =
                    (Integer) THREAD_MAP.get(resultSetCountKey);

                if  (resultSetCount == null)
                {
                    resultSetCount = new Integer(1);
                }
                else
                {
                    resultSetCount =
                        new Integer(resultSetCount.intValue() + 1);
                }

                THREAD_MAP.put(resultSetCountKey, resultSetCount);
            }

            THREAD_MAP.put(
                key, new Integer(rowsRetrieved.intValue() + 1));
        }
    }

    /**
     * Annotates a result-set is closed.
     * @param resultSetExtractor the ResultSet extractor.
     */
    public void annotateResultSetClosed(
        final <input.tr_name_capitalized>ResultSetExtractor resultSetExtractor)
    {
        synchronized  (THREAD_MAP)
        {
            Object resultSetCountKey = buildResultSetCountKey();

            Integer resultSetCount =
                (Integer) THREAD_MAP.get(resultSetCountKey);

            if  (resultSetCount == null)
            {
                resultSetCount = new Integer(1);
            }
            else
            {
                resultSetCount =
                    new Integer(resultSetCount.intValue() + 1);
            }

            THREAD_MAP.put(resultSetCountKey, resultSetCount);
        }
    }

    /**
     * Builds a resultset key for given thread.
     * @param thread the thread.
     * @return such key.
     */
    protected Object buildResultSetKey(final Thread thread)
    {
        return "resultset-thread-key::" + thread.hashCode();
    }

    /**
     * Retrieves the number of rows fetched for the last annotated result-set.
     * @return such information.
     */
    public int getLastResultSetRetrievedRows()
    {
        Integer result = null;

        synchronized  (THREAD_MAP)
        {
            result =
                (Integer)
                    THREAD_MAP.get(
                        buildResultSetKey(
                            Thread.currentThread()));
        }

        return (result == null) ? 0 : result.intValue();
    }

    /**
     * Builds a result-set count key.
     * @return such key.
     */
    protected Object buildResultSetCountKey()
    {
        return "::resultset-count-key::";
    }

    /**
     * Retrieves the number of used result-set so far.
     * @return such information.
     */
    public int getResultSetCount()
    {
        Integer result = null;

        synchronized  (THREAD_MAP)
        {
            result =
                (Integer)
                    THREAD_MAP.get(buildResultSetCountKey());
        }

        return (result == null) ? 0 : result.intValue();
    }

}
>>
