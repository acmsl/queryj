//;-*- mode: antlr -*-
//
//                      QueryJ
//
//  Copyright (C) 2002-2007  ACM-SL
//                           chous@acm-sl.org
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU General Public
//  License as published by the Free Software Foundation; either
//  version 2 of the License, or any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  General Public License for more details.
//
//  You should have received a copy of the GNU General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//  Thanks to ACM S.L. for distributing this library under the GPL license.
//  Contact info: jose.sanleandro@acm-sl.com
//  Postal Address: c/Playa de Lagoa, 1
//                  Urb. Valdecabanas
//                  Boadilla del monte
//                  28660 Madrid
//                  Spain
//
//***************************************************************************
//
// Filename: StatisticsProvider.stg
//
// Author: Jose San Leandro Armendariz
//
// Description: Generates StatisticsProvider sources.
//
// Version: $Revision: 1769 $ ($Author: chous $ at $Date: 2007-04-23 10:14:02 +0200 (Mon, 23 Apr 2007) $)
//
// $Id: StatisticsProvider.stg 1769 2007-04-23 08:14:02Z chous $
//
group StatisticsProvider;

source(input) ::= <<
<!
  Generates a StatisticsProvider source.
  @param input.copyright_years the copyright's years.
  @param input.package the package.
  @params class
!>
<if(input.header)>
<input.header>
<else>
<java_header(
  years=input.copyright_years,
  description=
  [
    first_line_description()
  ],
  timestamp=input.timestamp)>
<endif>
// Generated by $Id: DAO.stg 1769 2007-04-23 08:14:02Z chous $

<package_declaration(
  packageNames=
  [
    input.base_package_name,
    typeInitMap.baseDAOSubpackageName,
    typeInitMap.rdbSubpackageName
  ])>

/*
 * Importing some Spring classes.
 */
import org.springframework.jdbc.core.ConnectionCallback;
import org.springframework.jdbc.core.StatementCallback;
import org.springframework.jdbc.core.PreparedStatementCallback;
import org.springframework.jdbc.core.PreparedStatementCreator;

/*
 * Importing some JDK classes.
 */
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

<class(input=input)>
>>

first_line_description() ::= <<
<!
  Generates a description for the generated file.
!>
Provides statistics about QueryJ-generated persistence layer.
>>

class(input) ::= <<
<!
 Generates the class body.
 @param input.timestamp the timestamp.
 @param input.tr_name the table repository name.
!>
/**
 * <[
      first_line_description()
    ]:{line |<line>}; separator="\n * ">
 * @author \<a href="http://www.acm-sl.org/queryj"\>QueryJ\</a\>
 * @version <"$">Revision: $ (<"$">Author: $ at <"$">Date: $)
 * @since <input.timestamp>
 */
public class <input.tr_name_capitalized>StatisticsProvider
{
    /**
     * Singleton implemented to avoid double-check locking.
     */
    protected static final class <input.tr_name_capitalized>StatisticsProviderSingletonContainer
    {
        /**
         * The actual singleton.
         */
        public static final <input.tr_name_capitalized>StatisticsProvider SINGLETON =
            new <input.tr_name_capitalized>StatisticsProvider();
    }

    /**
     * Retrieves the singleton instance.
     * @return such instance.
     */
    public static <input.tr_name_capitalized>StatisticsProvider getInstance()
    {
        return <input.tr_name_capitalized>StatisticsProviderSingletonContainer.SINGLETON;
    }

    /**
     * Annotates an operation on the persistence
     * layer takes place.
     * @param sql the sql sentence.
     * @param parameters the sql parameters.
     */
    public void annotatePreparedStatementExecuted(
        final String sql, final Object[] parameters)
    {
        // TODO
    }

    /**
     * Annotates a connection is retrieved.
     * @param jdbcTemplate the actual \<code><input.tr_name_capitalized>JdbcTemplate\</code>.
     * @param connectionCallback the connection callback.
     */
    public void annotateConnectionRetrieved(
        final <input.tr_name_capitalized>JdbcTemplate jdbcTemplate,
        final ConnectionCallback connectionCallback)
    {
        // TODO
    }

    /**
     * Annotates a connection is retrieved.
     * @param jdbcTemplate the actual \<code><input.tr_name_capitalized>JdbcTemplate\</code>.
     * @param preparedStatementCallback the prepared-statement callback.
     */
    public void annotateConnectionRetrieved(
        final <input.tr_name_capitalized>JdbcTemplate jdbcTemplate,
        final PreparedStatementCallback preparedStatementCallback)
    {
        // TODO
    }

    /**
     * Annotates a connection is released.
     * @param jdbcTemplate the actual \<code><input.tr_name_capitalized>JdbcTemplate\</code>.
     * @param connectionCallback the connection callback.
     */
    public void annotateConnectionReleased(
        final <input.tr_name_capitalized>JdbcTemplate jdbcTemplate,
        final ConnectionCallback connectionCallback)
    {
        // TODO
    }

    /**
     * Annotates a connection is released.
     * @param jdbcTemplate the actual \<code><input.tr_name_capitalized>JdbcTemplate\</code>.
     * @param preparedStatementCallback the prepared-statement callback.
     */
    public void annotateConnectionReleased(
        final <input.tr_name_capitalized>JdbcTemplate jdbcTemplate,
        final PreparedStatementCallback preparedStatementCallback)
    {
        // TODO
    }

    /**
     * Annotates a statement is created.
     * @param jdbcTemplate the actual \<code><input.tr_name_capitalized>JdbcTemplate\</code>.
     * @param preparedStatementCreator the statement creator.
     */
    public void annotateStatementCreated(
        final <input.tr_name_capitalized>JdbcTemplate jdbcTemplate,
        final PreparedStatementCreator preparedStatementCreator)
    {
        // TODO
    }

    /**
     * Annotates a statement is prepared.
     * @param sql the sql.
     */
    public void annotateStatementPrepared(final String sql)
    {
        // TODO
    }

    /**
     * Annotates a statement is released.
     * @param jdbcTemplate the actual \<code><input.tr_name_capitalized>JdbcTemplate\</code>.
     * @param preparedStatementCreator the statement creator.
     */
    public void annotateStatementReleased(
        final <input.tr_name_capitalized>JdbcTemplate jdbcTemplate,
        final PreparedStatementCreator preparedStatementCreator)
    {
        // TODO
    }

    /**
     * Annotates a result-set moves forward one row.
     * @param resultSetExtractor the ResultSet extractor.
     */
    public void annotateResultSetMovedForward(
        final <input.tr_name_capitalized>ResultSetExtractor resultSetExtractor)
    {
        // TODO
    }

    /**
     * Annotates a result-set is closed.
     * @param resultSetExtractor the ResultSet extractor.
     */
    public void annotateResultSetClosed(
        final <input.tr_name_capitalized>ResultSetExtractor resultSetExtractor)
    {
        // TODO
    }

    /**
     * A map whose keys are limitted in number.
     * @author \<a href="http://www.acm-sl.org/queryj"\>QueryJ\</a\>
     * @version <"$">Revision: $ (<"$">Author: $ at <"$">Date: $)
     * @since <input.timestamp>
     */
    public static class KeyBoundedMapDecorator
        implements  Map
    {
        /**
         * The actual map.
         */
        private Map m__DecoratedMap;

        /**
         * The max size.
         */
        private int m__iMaxSize;

        /**
         * A list with the map keys, ordered by insertion time.
         */
        private List m__lKeys;

        /**
         * Builds a \<code>BoundedMapDecorator\</code> instance.
         * @param map the map to decorate.
         * @param size the upper bound.
         */
        public KeyBoundedMapDecorator(
            final Map map, final int size)
        {
            immutableSetDecoratedMap(map);
            immutableSetMaxSize(size);
            immutableSetKeyList(new ArrayList());
        }

        /**
         * Specifies the decorated map.
         * @param map such map.
         */
        protected final void immutableSetDecoratedMap(final Map map)
        {
            m__DecoratedMap = map;
        }

        /**
         * Specifies the decorated map.
         * @param map such map.
         */
        protected void setDecoratedMap(final Map map)
        {
            immutableSetDecoratedMap(map);
        }

        /**
         * Retrieves the decorated map.
         * @return such map.
         */
        public Map getDecoratedMap()
        {
            return m__DecoratedMap;
        }

        /**
         * Specifies the max size.
         * @param size such information.
         */
        protected final void immutableSetMaxSize(final int size)
        {
            m__iMaxSize = size;
        }

        /**
         * Specifies the max size.
         * @param size such information.
         */
        protected void setMaxSize(final int size)
        {
            immutableSetMaxSize(size);
        }

        /**
         * Retrieves the max size.
         * @return such information.
         */
        public int getMaxSize()
        {
            return m__iMaxSize;
        }

        /**
         * Specifies the key list.
         * @param list such list.
         */
        protected final void immutableSetKeyList(final List list)
        {
            m__lKeys = list;
        }

        /**
         * Specifies the key list.
         * @param list such list.
         */
        protected void setKeyList(final List list)
        {
            immutableSetKeyList(list);
        }

        /**
         * Retrieves the key list.
         * @return such list.
         */
        public List getKeyList()
        {
            return m__lKeys;
        }

        /**
         * Returns the size of the decorated map.
         *
         * @return such information.
         */
        public int size()
        {
            return size(getDecoratedMap());
        }

        /**
         * Returns the size of the decorated map.
         * @param decoratedMap the decorated map.
         * @return such information.
         */
        protected int size(final Map decoratedMap)
        {
            return decoratedMap.size();
        }

        /**
         * Checks whether the decorated map is empty.
         *
         * @return \<tt>true\</tt> in such case.
         */
        public boolean isEmpty()
        {
            return isEmpty(getDecoratedMap());
        }
    
        /**
         * Checks whether the decorated map is empty.
         * @param decoratedMap the decorated map.
         * @return \<tt>true\</tt> in such case.
         */
        protected boolean isEmpty(final Map decoratedMap)
        {
            return decoratedMap.isEmpty();
        }
    
        /**
         * Checks whether the decorated map contains given key.
         * @param key key whose presence in this map is to be tested.
         * @return \<tt>true\</tt> in such case.
         * 
         * @throws ClassCastException if the key is of an inappropriate type for
         * 		  this map (optional).
         * @throws NullPointerException if the key is \<tt>null\</tt> and this map
         *            does not permit \<tt>null\</tt> keys (optional).
         */
        public boolean containsKey(final Object key)
        {
            return containsKey(key, getDecoratedMap());
        }

        /**
         * Checks whether the decorated map contains given key.
         * @param decoratedMap the decorated map.
         * @param key key whose presence in this map is to be tested.
         * @return \<tt>true\</tt> in such case.
         * 
         * @throws ClassCastException if the key is of an inappropriate type for
         * 		  this map (optional).
         * @throws NullPointerException if the key is \<tt>null\</tt> and this map
         *            does not permit \<tt>null\</tt> keys (optional).
         */
        protected boolean containsKey(final Object key, final Map decoratedMap)
        {
            return decoratedMap.containsKey(key);
        }

        /**
         * Checks whether the decorated map contains given value.
         * @param value value whose presence in this map is to be tested.
         * @return \<tt>true\</tt> in such case.
         * @throws ClassCastException if the value is of an inappropriate type for
         * 		  this map (optional).
         * @throws NullPointerException if the value is \<tt>null\</tt> and this map
         *            does not permit \<tt>null\</tt> values (optional).
         */
        public boolean containsValue(final Object value)
        {
            return containsValue(value, getDecoratedMap());
        }

        /**
         * Checks whether the decorated map contains given value.
         * @param value value whose presence in this map is to be tested.
         * @return \<tt>true\</tt> in such case.
         * @throws ClassCastException if the value is of an inappropriate type for
         * 		  this map (optional).
         * @throws NullPointerException if the value is \<tt>null\</tt> and this map
         *            does not permit \<tt>null\</tt> values (optional).
         */
        protected boolean containsValue(final Object value, final Map decoratedMap)
        {
            return decoratedMap.containsValue(value);
        }

        /**
         * Retrieves the value associated to given key in the decorated map.
         * @param key key whose associated value is to be returned.
         * @return the value to which this map maps the specified key, or
         * \<tt>null\</tt> if the decorated map contains no mappingfor this key.
         * 
         * @throws ClassCastException if the key is of an inappropriate type for
         * 		  this map (optional).
         * @throws NullPointerException if the key is \<tt>null\</tt> and this map
         *		  does not permit \<tt>null\</tt> keys (optional).
         * 
         */
        public Object get(final Object key)
        {
            return get(key, getDecoratedMap());
        }
    
        /**
         * Retrieves the value associated to given key in the decorated map.
         * @param key key whose associated value is to be returned.
         * @return the value to which this map maps the specified key, or
         * \<tt>null\</tt> if the decorated map contains no mappingfor this key.
         * 
         * @throws ClassCastException if the key is of an inappropriate type for
         * 		  this map (optional).
         * @throws NullPointerException if the key is \<tt>null\</tt> and this map
         *		  does not permit \<tt>null\</tt> keys (optional).
         * 
         */
        protected Object get(final Object key, final Map decoratedMap)
        {
            return decoratedMap.get(key);
        }
    
        // Modification Operations
    
        /**
         * Associates the specified value with the specified key in the decorated map
         * (optional operation).  If the map previously contained a mapping for
         * this key, the old value is replaced by the specified value. 
         *
         * @param key key with which the specified value is to be associated.
         * @param value value to be associated with the specified key.
         * @return previous value associated with specified key, or \<tt>null\</tt>
         *	       if there was no mapping for key.  A \<tt>null\</tt> return can
         *	       also indicate that the map previously associated \<tt>null\</tt>
         *	       with the specified key, if the implementation supports
         *	       \<tt>null\</tt> values.
         * 
         * @throws UnsupportedOperationException if the \<tt>put\</tt> operation is
         *	          not supported by this map.
         * @throws ClassCastException if the class of the specified key or value
         * 	          prevents it from being stored in this map.
         * @throws IllegalArgumentException if some aspect of this key or value
         *	          prevents it from being stored in this map.
         * @throws NullPointerException if this map does not permit \<tt>null\</tt>
         *            keys or values, and the specified key or value is
         *            \<tt>null\</tt>.
         */
        public Object put(final Object key, final Object value)
        {
            return put(key, value, getDecoratedMap(), getMaxSize(), getKeyList());
        }
    
        /**
         * Associates the specified value with the specified key in the decorated map
         * (optional operation).  If the map previously contained a mapping for
         * this key, the old value is replaced by the specified value. 
         *
         * @param key key with which the specified value is to be associated.
         * @param value value to be associated with the specified key.
         * @param decoratedMap the decorated map.
         * @param maxSize the maximum size of the map.
         * @param keyList the key list.
         * @return previous value associated with specified key, or \<tt>null\</tt>
         *	       if there was no mapping for key.  A \<tt>null\</tt> return can
         *	       also indicate that the map previously associated \<tt>null\</tt>
         *	       with the specified key, if the implementation supports
         *	       \<tt>null\</tt> values.
         * 
         * @throws UnsupportedOperationException if the \<tt>put\</tt> operation is
         *	          not supported by this map.
         * @throws ClassCastException if the class of the specified key or value
         * 	          prevents it from being stored in this map.
         * @throws IllegalArgumentException if some aspect of this key or value
         *	          prevents it from being stored in this map.
         * @throws NullPointerException if this map does not permit \<tt>null\</tt>
         *            keys or values, and the specified key or value is
         *            \<tt>null\</tt>.
         */
        protected Object put(
            final Object key,
            final Object value,
            final Map decoratedMap,
            final int maxSize,
            final List keyList)
        {
            Object result = decoratedMap.put(key, value);

            if  (keyList.contains(key))
            {
                // Put the key as the newest item.
                keyList.remove(key);
            }

            keyList.add(key);

            if  (keyList.size() > maxSize)
            {
                Object t_OldestKey = keyList.get(0);

                if  (t_OldestKey != null)
                {
                    decoratedMap.remove(t_OldestKey);
                }

                keyList.remove(0);
            }

            return result;
        }
    
        /**
         * Removes the mapping for this key from this map if it is present
         * (optional operation).
         *
         * Returns the value to which the decorated map previously associated the key, or
         * \<tt>null\</tt> if the map contained no mapping for this key.  (A
         * \<tt>null\</tt> return can also indicate that the map previously
         * associated \<tt>null\</tt> with the specified key if the implementation
         * supports \<tt>null\</tt> values.)  The map will not contain a mapping for
         * the specified  key once the call returns.
         *
         * @param key key whose mapping is to be removed from the map.
         * @return previous value associated with specified key, or \<tt>null\</tt>
         *	       if there was no mapping for key.
         *
         * @throws ClassCastException if the key is of an inappropriate type for
         * 		  this map (optional).
         * @throws NullPointerException if the key is \<tt>null\</tt> and this map
         *            does not permit \<tt>null\</tt> keys (optional).
         * @throws UnsupportedOperationException if the \<tt>remove\</tt> method is
         *         not supported by this map.
         */
        public Object remove(final Object key)
        {
            return remove(key, getDecoratedMap(), getKeyList());
        }
    
        /**
         * Removes the mapping for this key from this map if it is present
         * (optional operation).
         *
         * Returns the value to which the decorated map previously associated the key, or
         * \<tt>null\</tt> if the map contained no mapping for this key.  (A
         * \<tt>null\</tt> return can also indicate that the map previously
         * associated \<tt>null\</tt> with the specified key if the implementation
         * supports \<tt>null\</tt> values.)  The map will not contain a mapping for
         * the specified  key once the call returns.
         *
         * @param key key whose mapping is to be removed from the map.
         * @param decoratedMap the decorated map.
         * @param keyList the key list.
         * @return previous value associated with specified key, or \<tt>null\</tt>
         *	       if there was no mapping for key.
         *
         * @throws ClassCastException if the key is of an inappropriate type for
         * 		  this map (optional).
         * @throws NullPointerException if the key is \<tt>null\</tt> and this map
         *            does not permit \<tt>null\</tt> keys (optional).
         * @throws UnsupportedOperationException if the \<tt>remove\</tt> method is
         *         not supported by this map.
         */
        protected Object remove(
            final Object key, final Map decoratedMap, final List keyList)
        {
            Object result = decoratedMap.remove(key);

            keyList.remove(key);

            return result;
        }
    
    
        // Bulk Operations
    
        /**
         * Copies all of the mappings from the specified map to the decorated map
         * (optional operation). The behavior of this operation is unspecified if the
         * specified map is modified while the operation is in progress.
         *
         * @param t Mappings to be stored in this map.
         * 
         * @throws UnsupportedOperationException if the \<tt>putAll\</tt> method is
         * 		  not supported by this map.
         * 
         * @throws ClassCastException if the class of a key or value in the
         * 	          specified map prevents it from being stored in this map.
         * 
         * @throws IllegalArgumentException some aspect of a key or value in the
         *	          specified map prevents it from being stored in this map.
         * @throws NullPointerException if the specified map is \<tt>null\</tt>, or if
         *         this map does not permit \<tt>null\</tt> keys or values, and the
         *         specified map contains \<tt>null\</tt> keys or values.
         */
        public void putAll(final Map t)
        {
            putAll(t, getDecoratedMap(), getMaxSize(), getKeyList());
        }
    
        /**
         * Copies all of the mappings from the specified map to the decorated map
         * (optional operation). The behavior of this operation is unspecified if the
         * specified map is modified while the operation is in progress.
         *
         * @param t Mappings to be stored in this map.
         * @param decoratedMap the decorated map.
         * @param maxSize the maximum allowed size for the map keys.
         * @param keyList the list of keys.
         * @throws UnsupportedOperationException if the \<tt>putAll\</tt> method is
         * 		  not supported by this map.
         * 
         * @throws ClassCastException if the class of a key or value in the
         * 	          specified map prevents it from being stored in this map.
         * 
         * @throws IllegalArgumentException some aspect of a key or value in the
         *	          specified map prevents it from being stored in this map.
         * @throws NullPointerException if the specified map is \<tt>null\</tt>, or if
         *         this map does not permit \<tt>null\</tt> keys or values, and the
         *         specified map contains \<tt>null\</tt> keys or values.
         */
        protected void putAll(
            final Map t,
            final Map decoratedMap, 
            final int maxSize,
            final List keyList)
        {
            decoratedMap.putAll(t);

            List t_lNewKeyList = keyList;

            t_lNewKeyList.addAll(t.keySet());

            t_lNewKeyList = removeDuplicates(t_lNewKeyList);
            setKeyList(t_lNewKeyList);

            Object lastKey;

            while  (t_lNewKeyList.size() > maxSize)
            {
                lastKey = t_lNewKeyList.remove(0);
                decoratedMap.remove(lastKey);
            }
        }
    
        /**
         * Removes all mappings from the decorated map (optional operation).
         *
         * @throws UnsupportedOperationException clear is not supported by this
         * 		  map.
         */
        public void clear()
        {
            clear(getDecoratedMap(), getKeyList());
        }
    
        /**
         * Removes all mappings from the decorated map (optional operation).
         *
         * @param decoratedMap the decorated map.
         * @param keyList the key list.
         * @throws UnsupportedOperationException clear is not supported by this
         * 		  map.
         */
        protected void clear(final Map decoratedMap, final List keyList)
        {
            decoratedMap.clear();
            keyList.clear();
        }
    
        // Views
    
        /**
         * Returns a set view of the keys contained in the decorated map.
         * Note: the keys retrieved are not monitored, so changes in this set
         * would not be taken into account (regarding bound checking) until
         * the map changes using Map standard interface.
         * @return a set view of the keys contained in such map.
         */
        public Set keySet()
        {
            return getKeySet(getDecoratedMap()); 
        }

        /**
         * Returns a set view of the keys contained in the decorated map.
         * @param decoratedMap the decorated map.
         * @return a set view of the keys contained in such map.
         */
        protected Set getKeySet(final Map decoratedMap)
        {
            return decoratedMap.keySet();
        }

        /**
         * Returns a collection view of the values contained in the decorated map.
         * @return a collection view of the values contained in such map.
         */
        public Collection values()
        {
            return getValues(getDecoratedMap());
        }
    
        /**
         * Returns a collection view of the values contained in the decorated map.
         * @param decoratedMap the decorated map.
         * @return a collection view of the values contained in such map.
         */
        protected Collection getValues(final Map decoratedMap)
        {
            return decoratedMap.values();
        }
    
        /**
         * Returns a set view of the mappings contained in the decorated map.
         * Note: the keys retrieved are not monitored, so changes in this set
         * would not be taken into account (regarding bound checking) until
         * the map changes using Map standard interface.
         * @return a set view of the mappings contained in such map.
         */
        public Set entrySet()
        {
            return getEntrySet(getDecoratedMap());
        }

        /**
         * Returns a set view of the mappings contained in the decorated map.
         * @return a set view of the mappings contained in such map.
         */
        protected Set getEntrySet(final Map decoratedMap)
        {
            return decoratedMap.entrySet();
        }

        // Comparison and hashing
    
        /**
         * Compares the specified object with the decorated map for equality.
         * @param o object to be compared for equality with such map.
         * @return \<tt>true\</tt> if the specified object is equal to this map.
         */
        public boolean equals(final Object o)
        {
            return areEqual(o, getDecoratedMap());
        }
    
        /**
         * Compares the specified object with the decorated map for equality.
         * @param o object to be compared for equality with such map.
         * @param decoratedMap the decorated map.
         * @return \<tt>true\</tt> if the specified object is equal to this map.
         */
        protected boolean areEqual(final Object o, final Map decoratedMap)
        {
            return decoratedMap.equals(o);
        }
    
        /**
         * Returns the hash code value of the decorated instance.
         *
         * @return such hash code value.
         */
        public int hashCode()
        {
            return getHashCode(getDecoratedMap());
        }

        /**
         * Returns the hash code value of the decorated instance.
         * @param decoratedMap the decorated map.
         * @return such hash code value.
         */
        protected int getHashCode(final Map decoratedMap)
        {
            return decoratedMap.hashCode();
        }

        /**
         * Removes any duplicated entries in given list.
         * @param list the list.
         * @return the modified list.
         */
        protected List removeDuplicates(final List list)
        {
            List result = new ArrayList();

            int t_iCount = (list != null) ? list.size() : 0;

            Object t_Item;

            for  (int t_iIndex = 0; t_iIndex \< t_iCount; t_iIndex++)
            {
                t_Item = list.get(t_iIndex);

                if  (result.contains(t_Item))
                {
                    result.remove(t_Item);
                }

                result.add(t_Item);
            }

            return result;
        }
    }
}
>>
