//;-*- mode: antlr -*-
//
//                      QueryJ
//
//  Copyright (C) 2002-2007  ACM-SL
//                           chous@acm-sl.org
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU General Public
//  License as published by the Free Software Foundation; either
//  version 2 of the License, or any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  General Public License for more details.
//
//  You should have received a copy of the GNU General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//  Thanks to ACM S.L. for distributing this library under the GPL license.
//  Contact info: jose.sanleandro@acm-sl.com
//  Postal Address: c/Playa de Lagoa, 1
//                  Urb. Valdecabanas
//                  Boadilla del monte
//                  28660 Madrid
//                  Spain
//
//***************************************************************************
//
// Filename: StatisticsProviderMBeanPublisher.stg
//
// Author: Jose San Leandro Armendariz
//
// Description: Generates StatisticsProviderMBeanPublisher sources.
//
// Version: $Revision$ ($Author$ at $Date$)
//
// $Id$
//
group StatisticsProviderMBeanPublisher;

source(input) ::= <<
<!
  Generates a StatisticsProvider source.
  @param input.copyright_years the copyright's years.
  @param input.package the package.
  @params class
!>
<if(input.header)>
<input.header>
<else>
<java_header(
  years=input.copyright_years,
  description=
  [
    first_line_description()
  ],
  timestamp=input.timestamp)>
<endif>
// Generated by $Id$

<package_declaration(
  packageNames=
  [
    input.base_package_name,
    typeInitMap.baseDAOSubpackageName,
    typeInitMap.rdbSubpackageName
  ])>

<project_imports(
  basePackageName=input.base_package_name,
  baseDAOSubpackageName=typeInitMap.baseDAOSubpackageName,
  rdbSubpackageName=typeInitMap.rdbSubpackageName,
  trName=input.tr_name_capitalized)>

/*
 * Importing some JMX classes.
 */
import javax.management.MBeanOperationInfo;
import javax.management.MBeanParameterInfo;
import javax.management.MBeanServer;
import javax.management.MBeanServerFactory;
import javax.management.modelmbean.DescriptorSupport;
import javax.management.modelmbean.ModelMBeanAttributeInfo;
import javax.management.modelmbean.ModelMBeanInfo;
import javax.management.modelmbean.ModelMBeanOperationInfo;
import javax.management.modelmbean.ModelMBeanInfoSupport;
import javax.management.modelmbean.RequiredModelMBean;
import javax.management.ObjectInstance;
import javax.management.ObjectName;

/*
 * Importing some JDK classes.
 */
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

/*
 * Importing Apache Commons Logging classes.
 */
import org.apache.commons.logging.LogFactory;
;

<class(input=input)>
>>

project_imports(basePackageName, baseDAOSubpackageName, rdbSubpackageName, trName) ::= <<
<!
 Declares the project imports.
 @param basePackageName the base package name.
 @param baseDAOSubpackageName the base DAO subpackage name.
 @param rdbSubpackageName the rdb subpackage name.
 @param trName the repository name, capitalized.
!>
/**
 * Importing some project classes.
 */
import <basePackageName>.<baseDAOSubpackageName>.<rdbSubpackageName>.<trName>StatisticsProvider;
>>

first_line_description() ::= <<
<!
  Generates a description for the generated file.
!>
Provides statistics about QueryJ-generated persistence layer.
>>

class(input) ::= <<
<!
 Generates the class body.
 @param input.timestamp the timestamp.
 @param input.tr_name the table repository name.
!>
/**
 * <[
      first_line_description()
    ]:{line |<line>}; separator="\n * ">
 * @author \<a href="http://www.acm-sl.org/queryj"\>QueryJ\</a\>
 * @version <"$">Revision: $ (<"$">Author: $ at <"$">Date: $)
 * @since <input.timestamp>
 */
public class <input.tr_name_capitalized>StatisticsProviderMBeanPublisher
{
    /**
     * The JMX object name for <input.tr_name_capitalized>StatisticsProvider.
     */
    public static final String OBJECT_NAME =
        "<input.base_package_name>:service=<input.tr_name_capitalized>StatisticsProvider";

    /**
     * An empty mbean parameter info array.
     */
    protected static final MBeanParameterInfo[] EMPTY_MBEANPARAMETERINFO_ARRAY =
        new MBeanParameterInfo[0];

    /**
     * Singleton implemented to avoid double-check locking.
     */
    protected static final class <input.tr_name_capitalized>StatisticsProviderMBeanPublisherSingletonContainer
    {
        /**
         * The actual singleton.
         */
        public static final <input.tr_name_capitalized>StatisticsProviderMBeanPublisher SINGLETON =
            new <input.tr_name_capitalized>StatisticsProviderMBeanPublisher();
    }

    /**
     * Retrieves the singleton instance.
     * @return such instance.
     */
    public static <input.tr_name_capitalized>StatisticsProviderMBeanPublisher getInstance()
    {
        return <input.tr_name_capitalized>StatisticsProviderMBeanPublisherSingletonContainer.SINGLETON;
    }

    /**
     * Publishes values provided by \<code><input.tr_name_capitalized>StatisticsProvider\</code>
     * as an JMX MBean.
     */
    public void publish()
    {
        publish(
            <input.tr_name_capitalized>MBeanRegistrator.getMBeanServer(),
            <input.tr_name_capitalized>StatisticsProvider.getInstance());
    }

    /**
     * Publishes values provided by \<code><input.tr_name_capitalized>StatisticsProvider\</code>
     * as an JMX MBean.
     * @param server the MBean server.
     * @precondition statisticsProvider != null
     */
    protected void publish(
        final MBeanServer server,
        final <input.tr_name_capitalized>StatisticsProvider statisticsProvider)
    {
        if  (server == null)
        {
            LogFactory.getLog(<input.tr_name_capitalized>StatisticsProviderMBeanPublisher.class).warn(
                "No JMX server available.");
        }
        else
        {
            // Just a trick to ensure the mbean is not already registered.
            ensureMBeanUnregistered(
                <input.tr_name_capitalized>MBeanRegistrator.getMBeanServer(),
                statisticsProvider);

            ObjectName name = null;

            RequiredModelMBean modelMBean = null;

            try 
            {
                 name = new ObjectName(OBJECT_NAME);
                 modelMBean = new RequiredModelMBean();
            }
            catch  (final Throwable throwable)
            {
                LogFactory.getLog(<input.tr_name_capitalized>StatisticsProviderMBeanPublisher.class).warn(
                     "Cannot register the <input.tr_name_capitalized>StatisticsProvider "
                   + "MBean.",
                   throwable);
            }

            String[][] fields = initializeFields(statisticsProvider);

            ModelMBeanAttributeInfo[] attributeInfo =
                initializeAttributes(fields);

            // operations (must also include getters/setters)
            ModelMBeanOperationInfo[] operationInfo =
                initializeOperations();

            ModelMBeanInfo mbeanInfo =
                new ModelMBeanInfoSupport(
                    modelMBean.getClass().getName(),
                    "<input.tr_name_capitalized>StatisticsProvider Model MBean",
                    attributeInfo,
                    null,
                    operationInfo,
                    null);
            try 
            {
                if  (name != null)
                {
                    modelMBean.setModelMBeanInfo(mbeanInfo);
                    modelMBean.setManagedResource(
                        statisticsProvider,
                        "ObjectReference");
                    <input.tr_name_capitalized>MBeanRegistrator.register(modelMBean, name);
                }
            }
            catch  (final Throwable throwable)
            {
                LogFactory.getLog(<input.tr_name_capitalized>StatisticsProviderMBeanPublisher.class).warn(
                     "Cannot register the <input.tr_name_capitalized>StatisticsProvider "
                   + "MBean.",
                   throwable);
            }
        }
    }

    /**
     * Unregisters the mbean.
     */
    public void ensureMBeanUnregistered()
    {
        ensureMBeanUnregistered(
            <input.tr_name_capitalized>MBeanRegistrator.getMBeanServer(),
            <input.tr_name_capitalized>StatisticsProvider.getInstance());
    }

    /**
     * Unregisters the mbean.
     * @param server the MBean server.
     * @param statisticsProvider the \<code><input.tr_name_capitalized>StatisticsProvider\</code>
     * instance.
     * @precondition statisticsProvider != null
     */
    protected void ensureMBeanUnregistered(
        final MBeanServer server,
        final <input.tr_name_capitalized>StatisticsProvider statisticsProvider)
    {
        if  (server != null)
        {
            try 
            {
                ObjectName name = new ObjectName(OBJECT_NAME);

                <input.tr_name_capitalized>MBeanRegistrator.unregister(name);
            }
            catch  (final Throwable throwable)
            {
                LogFactory.getLog(<input.tr_name_capitalized>StatisticsProviderMBeanPublisher.class).warn(
                     "Cannot register the <input.tr_name_capitalized>StatisticsProvider "
                   + "MBean.",
                   throwable);
            }
        }
    }

    /**
     * Initializes the fields metadata.
     * @param statisticsProvider the \<code><input.tr_name_capitalized>StatisticsProvider\</code>
     * instance.
     * return such fields.
     * @precondition statisticsProvider != null
     */
    protected String[][] initializeFields(
        final <input.tr_name_capitalized>StatisticsProvider statisticsProvider)
    {
        String[][] result = new String[6][8];

        result[0][0] = "name=LastConnectionSQL";
        result[0][1] = "descriptorType=attribute";
        result[0][2] = "displayName=LastConnectionSQL";
        result[0][3] = "getMethod=getLastConnectionSQL";
        //result[0][4] = "setMethod=setLastConnectionSQL";
        result[0][4] = "persistPolicy=Never";
        result[0][5] = "iterable=F";
        result[0][6] = "visibility=1";
        result[0][7] = "value=" + statisticsProvider.getLastConnectionSql();

        result[1][0] = "name=ConnectionCount";
        result[1][1] = "descriptorType=attribute";
        result[1][2] = "displayName=ConnectionCount";
        result[1][3] = "getMethod=getConnectionCount";
        //result[1][4] = "setMethod=getConnectionCount";
        result[1][4] = "persistPolicy=Never";
        result[1][5] = "iterable=F";
        result[1][6] = "visibility=1";
        result[1][7] = "value=" + statisticsProvider.getConnectionCount();

        result[2][0] = "name=LastStatementSQL";
        result[2][1] = "descriptorType=attribute";
        result[2][2] = "displayName=LastStatementSQL";
        result[2][3] = "getMethod=getLastStatementSQL";
        //result[2][4] = "setMethod=setLastStatementSQL";
        result[2][4] = "persistPolicy=Never";
        result[2][5] = "iterable=F";
        result[2][6] = "visibility=1";
        result[2][7] = "value=" + statisticsProvider.getLastStatementSql();

        result[3][0] = "name=StatementCount";
        result[3][1] = "descriptorType=attribute";
        result[3][2] = "displayName=StatementCount";
        result[3][3] = "getMethod=getStatementCount";
        //result[3][4] = "setMethod=getStatementCount";
        result[3][4] = "persistPolicy=Never";
        result[3][5] = "iterable=F";
        result[3][6] = "visibility=1";
        result[3][7] = "value=" + statisticsProvider.getStatementCount();

        result[4][0] = "name=LastResultSetRetrievedRows";
        result[4][1] = "descriptorType=attribute";
        result[4][2] = "displayName=LastResultSetRetrievedRows";
        result[4][3] = "getMethod=getLastResultSetRetrievedRows";
        //result[4][4] = "setMethod=getLastResultSetRetrievedRows";
        result[4][4] = "persistPolicy=Never";
        result[4][5] = "iterable=F";
        result[4][6] = "visibility=1";
        result[4][7] = "value=" + statisticsProvider.getLastResultSetRetrievedRows();

        result[5][0] = "name=ResultSetCount";
        result[5][1] = "descriptorType=attribute";
        result[5][2] = "displayName=ResultSetCount";
        result[5][3] = "getMethod=getResultSetCount";
        //result[5][4] = "setMethod=getResultSetCount";
        result[5][4] = "persistPolicy=Never";
        result[5][5] = "iterable=F";
        result[5][6] = "visibility=1";
        result[5][7] = "value=" + statisticsProvider.getResultSetCount();

        return result;
    }

    /**
     * Initializes the attributes metadata.
     * @param fields the fields.
     * return such attributes.
     * @precondition fields != null
     */
    protected ModelMBeanAttributeInfo[] initializeAttributes(
        final String[][] fields)
    {
        ModelMBeanAttributeInfo[] result =
            new ModelMBeanAttributeInfo[6];

        result[0] =
            new ModelMBeanAttributeInfo(
                "LastConnectionSQL", // Name
                String.class.getName(), // Type
                "The SQL of the last used connection.",
                true, // Is readable
                false, // Is writable
                false, // is boolean
                new DescriptorSupport(fields[0]));

        result[1] =
            new ModelMBeanAttributeInfo(
                "ConnectionCount", // Name
                Integer.TYPE.getName(), // Type
                "The number of connections used so far.",
                true, // Is readable
                false, // Is writable
                false, // is boolean
                new DescriptorSupport(fields[1]));

        result[2] =
            new ModelMBeanAttributeInfo(
                "LastStatementSQL", // Name
                String.class.getName(), // Type
                "The SQL of the last used statement.",
                true, // Is readable
                false, // Is writable
                false, // is boolean
                new DescriptorSupport(fields[2]));

        result[3] =
            new ModelMBeanAttributeInfo(
                "StatementCount", // Name
                Integer.TYPE.getName(), // Type
                "The number of statements used so far.",
                true, // Is readable
                false, // Is writable
                false, // is boolean
                new DescriptorSupport(fields[3]));

        result[4] =
            new ModelMBeanAttributeInfo(
                "LastResultSetRetrievedRows", // Name
                Integer.TYPE.getName(), // Type
                "The number of rows fetched in last resultset.",
                true, // Is readable
                false, // Is writable
                false, // is boolean
                new DescriptorSupport(fields[4]));

        result[5] =
            new ModelMBeanAttributeInfo(
                "ResultSetCount", // Name
                Integer.TYPE.getName(), // Type
                "The number of resultsets used so far.",
                true, // Is readable
                false, // Is writable
                false, // is boolean
                new DescriptorSupport(fields[5]));

        return result;
    }

    /**
     * Initializes the operations metadata.
     * return such attributes.
     */
    protected ModelMBeanOperationInfo[] initializeOperations()
    {
        ModelMBeanOperationInfo[] result =
            new ModelMBeanOperationInfo[6];

        DescriptorSupport operationDescriptor =
            new DescriptorSupport(
                new String[]
                {
                    "name=LastConnectionSQL",
                    "descriptorType=operation",
                    "role=getter"
                });

        result[0] =
            new ModelMBeanOperationInfo(
                "getLastConnectionSQL", 
                "Retrieves the SQL of the last connection",
                EMPTY_MBEANPARAMETERINFO_ARRAY,
                String.class.getName(),
                MBeanOperationInfo.INFO,
                operationDescriptor);

        operationDescriptor =
            new DescriptorSupport(
                new String[]
                {
                    "name=ConnectionCount",
                    "descriptorType=operation",
                    "role=getter"
                });

        result[1] =
            new ModelMBeanOperationInfo(
                "getConnectionCount", 
                "Retrieves the number of connections used so far",
                EMPTY_MBEANPARAMETERINFO_ARRAY,
                Integer.TYPE.getName(),
                MBeanOperationInfo.INFO,
                operationDescriptor);

        operationDescriptor =
            new DescriptorSupport(
                new String[]
                {
                    "name=LastStatementSQL",
                    "descriptorType=operation",
                    "role=getter"
                });

        result[2] =
            new ModelMBeanOperationInfo(
                "getLastStatementSQL", 
                "Retrieves the SQL of the last statement",
                EMPTY_MBEANPARAMETERINFO_ARRAY,
                String.class.getName(),
                MBeanOperationInfo.INFO,
                operationDescriptor);

        operationDescriptor =
            new DescriptorSupport(
                new String[]
                {
                    "name=StatementCount",
                    "descriptorType=operation",
                    "role=getter"
                });

        result[3] =
            new ModelMBeanOperationInfo(
                "getStatementCount", 
                "Retrieves the number of statements used so far",
                EMPTY_MBEANPARAMETERINFO_ARRAY,
                Integer.TYPE.getName(),
                MBeanOperationInfo.INFO,
                operationDescriptor);

        operationDescriptor =
            new DescriptorSupport(
                new String[]
                {
                    "name=LastResultSetRetrievedRows",
                    "descriptorType=operation",
                    "role=getter"
                });

        result[4] =
            new ModelMBeanOperationInfo(
                "getLastResultSetRetrievedRows", 
                "Retrieves the number of rows fetched by last result-set",
                EMPTY_MBEANPARAMETERINFO_ARRAY,
                Integer.TYPE.getName(),
                MBeanOperationInfo.INFO,
                operationDescriptor);

        operationDescriptor =
            new DescriptorSupport(
                new String[]
                {
                    "name=ResultSetCount",
                    "descriptorType=operation",
                    "role=getter"
                });

        result[5] =
            new ModelMBeanOperationInfo(
                "getResultSetCount", 
                "Retrieves the number of result-sets used so far",
                EMPTY_MBEANPARAMETERINFO_ARRAY,
                Integer.TYPE.getName(),
                MBeanOperationInfo.INFO,
                operationDescriptor);

        return result;
    }

    /**
     * Is able to register MBeans.
     * @author \<a href="http://www.acm-sl.org/queryj"\>QueryJ\</a\>
     * @version <"$">Revision: $ (<"$">Author: $ at <"$">Date: $)
     * @since <input.timestamp>
     */
    protected static class <input.tr_name_capitalized>MBeanRegistrator
    {
        /**
         * Cached reference to the mbean server.
         */
        private static MBeanServer server;
    
        /**
         * Registers a MBean from given its class name and an object name.
         * @param mbeanClassName the class name.
         * @param objectName the object name.
         * @return \<code\>true\</code\> if the MBean is registered successfully.
         * @precondition objectName != null
         * @precondition mbeanClassName != null
         */
        public static boolean register(final String mbeanClassName, final String objectName)
        {
            boolean result = false;
    
            try
            {
                result =
                    register(
                        Class.forName(mbeanClassName).newInstance(),
                        new ObjectName(objectName));
            }
            catch  (final Throwable throwable)
            {
                LogFactory.getLog(<input.tr_name_capitalized>MBeanRegistrator.class).warn(
                      "Specified object name and/or MBean class name are not "
                    + "suitable of being registered in the MBean server.",
                    throwable);
            }
    
            return result;
        }
    
        /**
         * Registers a MBean from given its class name and an object name.
         * @param mbeanClassName the class name.
         * @param objectName the object name.
         * @return \<code\>true\</code\> if the MBean is registered successfully.
         * @precondition mbeanClassName != null
         * @precondition objectName != null
         */
        public static boolean register(final Object mbean, final ObjectName objectName)
        {
            return register(mbean, objectName, getMBeanServer());
        }
    
        /**
         * Registers a MBean from given its class name and an object name.
         * @param mbeanClassName the class name.
         * @param objectName the object name.
         * @param server the server.
         * @return \<code\>true\</code\> if the MBean is registered successfully.
         * @precondition mbeanClassName != null
         * @precondition objectName != null
         */
        protected static boolean register(
            final Object mbean, final ObjectName objectName, final MBeanServer server)
        {
            boolean result = false;
    
            ObjectName objName = null;
    
            try
            {
                if  (   (server != null)
                     && (!server.isRegistered(objectName)))
                {
                    server.registerMBean(mbean, objectName);
    
                    result = true;
                }
                else 
                {
                    LogFactory.getLog(<input.tr_name_capitalized>MBeanRegistrator.class).info(
                        objectName + " is already registered.");
                }
            }
            catch  (final Throwable throwable)
            {
                LogFactory.getLog(<input.tr_name_capitalized>MBeanRegistrator.class).warn(
                      "Specified object name and/or MBean class name are not "
                    + "suitable of being registered in the MBean server.",
                    throwable);
            }
    
            return result;
        }
    
        /**
         * Unregisters a MBean from given object name.
         * @param objectName the object name.
         * @return \<code\>true\</code\> if the MBean is registered successfully.
         * @precondition objectName != null
         */
        public static boolean unregister(final String objectName)
        {
            boolean result = false;
    
            try
            {
                result = unregister(new ObjectName(objectName));
            }
            catch  (final Throwable throwable)
            {
                LogFactory.getLog(<input.tr_name_capitalized>MBeanRegistrator.class).warn(
                      "Specified object name is not "
                    + "suitable of being unregistered in the MBean server.",
                    throwable);
            }
    
            return result;
        }
    
        /**
         * Unregisters a MBean from given an object name.
         * @param objectName the object name.
         * @return \<code\>true\</code\> if the MBean is unregistered successfully.
         * @precondition objectName != null
         */
        public static boolean unregister(final ObjectName objectName)
        {
            return unregister(objectName, getMBeanServer());
        }
    
        /**
         * Unregisters a MBean from given an object name.
         * @param objectName the object name.
         * @param server the MBean server.
         * @return \<code\>true\</code\> if the MBean is unregistered successfully.
         * @precondition objectName != null
         */
        protected static boolean unregister(
            final ObjectName objectName, final MBeanServer server)
        {
            boolean result = false;
    
            ObjectName objName = null;
    
            try
            {
                if  (   (server != null)
                     && (server.isRegistered(objectName)))
                {
                    server.unregisterMBean(objectName);
    
                    result = true;
                }
                else 
                {
                    LogFactory.getLog(<input.tr_name_capitalized>MBeanRegistrator.class).info(
                        objectName + " is not registered.");
                }
            }
            catch  (final Throwable throwable)
            {
                LogFactory.getLog(<input.tr_name_capitalized>MBeanRegistrator.class).warn(
                      "Specified object name is not "
                    + "suitable of being unregistered in the MBean server.",
                    throwable);
            }
    
            return result;
        }
    
        /**
         * Obtains a reference to the MBean server. If at least one
         * MBean server already exists, then a reference to that MBean
         * server is returned. Otherwise a new instance is created.
         * @return such server.
         */
        public static MBeanServer getMBeanServer()
        {
            if  (server == null)
            {
                List mbeanServers = MBeanServerFactory.findMBeanServer(null);
    
                Iterator serverIterator = mbeanServers.iterator();
    
                while  (serverIterator.hasNext())
                {
                    MBeanServer mbeanServer = (MBeanServer) serverIterator.next();
    
                    Set mbeans = mbeanServer.queryMBeans(null, null);
    
                    Iterator mbeanIterator = mbeans.iterator();
    
                    while  (mbeanIterator.hasNext())
                    {
                        ObjectInstance objectInstance =
                            (ObjectInstance) mbeanIterator.next();
                    }
                }
    
                server =
                    (mbeanServers.size() \> 0)
                    ?  (MBeanServer) mbeanServers.get(0)
                    :   MBeanServerFactory.createMBeanServer();
            }
    
            return server;
        }
    }
}
>>
