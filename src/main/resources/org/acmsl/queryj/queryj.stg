//;-*- mode: antlr -*-
//
//                      QueryJ
//
//  Copyright (C) 2002-2007  ACM-SL
//                           chous@acm-sl.org
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU General Public
//  License as published by the Free Software Foundation; either
//  version 2 of the License, or any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  General Public License for more details.
//
//  You should have received a copy of the GNU General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//  Thanks to ACM S.L. for distributing this library under the GPL license.
//  Contact info: jose.sanleandro@acm-sl.com
//  Postal Address: c/Playa de Lagoa, 1
//                  Urb. Valdecabanas
//                  Boadilla del monte
//                  28660 Madrid
//                  Spain
//
//***************************************************************************
//
// Filename: queryj.stg
//
// Author: Jose San Leandro Armendariz
//
// Description: Defines the common template rules in QueryJ theme.
//
// Version: $Revision: 2493 $ ($Author: jjuan $ at $Date: 2008-07-10 11:45:12 +0200 (Thu, 10 Jul 2008) $)
//
// $Id: queryj.stg 2493 2008-07-10 09:45:12Z jjuan $
group queryj;

typeInitMap ::= [
  "empty":"",
  "jdbcOperationsSubpackageName":"jdbc",
  "baseDAOSubpackageName":"dao",
  "voSubpackageName":"vo",
  "voFactorySubpackageName":"vo",
  "rdbSubpackageName":"rdb",
  "tableRepositorySubpackageName":"tables",
  "functionsRepositorySubpackageName":"functions",
  "dataAccessManagerSubpackageName":"dao",
  "foreignKeyStatementSetterSubpackageName":"dao.rdb",
  "xmlSubpackageName":"xml",
  "mockSubpackageName":"mock"
]

java_header(years,description,timestamp) ::= <<
<! Generates the copyright header !>
<! @param years the copyright years. !>
<! @param description the description. !>
<! @param timestamp the timestamp. !>
/*
                        QueryJ

    Copyright (C) <years; separator="-"> Jose San Leandro Armendariz
                              chous@acm-sl.org

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    General Public License for more details.

    You should have received a copy of the GNU General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    Thanks to ACM S.L. for distributing this library under the GPL license.
    Contact info: jose.sanleandro@acm-sl.com
    Postal Address: c/Playa de Lagoa, 1
                    Urb. Valdecabanas
                    Boadilla del monte
                    28660 Madrid
                    Spain

 ******************************************************************************
 *
 * Author: QueryJ
 *
 * Description: <description:{line | <line>}; separator="\n *              ">
 *
 * Last modified by: <"$">Author: $ at <"$">Date: $
 *
 * <"$">Id: $
 *
 * Generation timestamp: <timestamp>
 */
>>

package_declaration(packageNames) ::= <<
<! Generates the package declaration !>
<! @param packageNames the package names !>
package <packageNames; separator=".">;
>>

precondition_notnull(name) ::= <<
<!
  Writes the Javadoc precondition for a concrete parameter.
  @param name the name of the parameter.
!>
* @precondition <name> != null
>>

precondition_instanceof(name, className) ::= <<
<!
  Writes the Javadoc precondition for a concrete parameter.
  @param name the name of the parameter.
  @param className the class name.
!>
* @precondition <name> instanceof <className>
>>

precondition(expression) ::= <<
<!
  Writes the Javadoc precondition for given expression.
  @param expression the expression
!>
* @precondition <expression>
>>

attribute_javadoc(name) ::= <<
<!
  Writes the Javadoc for a attribute parameter.
  @param name the name of the attribute.
!>
* @param <name> the \<i><name>\</i> value.
>>

attribute_declaration(attr) ::= <<
<!
  Writes the parameter declaration for a concrete attribute.
  @param attr the attribute.
!>
final <if(attr.clob)>String<else><attr.fieldType><endif> <attr.nameLowercased>
>>

attribute_declaration_impl(attr) ::= <<
<!
  Writes the parameter declaration for a concrete attribute.
  @param attr the attribute.
!>
final <if(attr.clob)>String<else><attr.javaType><endif> <attr.nameLowercased>
>>

attribute_isolated_declaration(attr) ::= <<
<!
  Writes the parameter declaration for a concrete attribute, isolated.
  @param attr the attribute.
!>
<attribute_declaration(attr=attr)>,
>>

attribute_isolated_declaration_impl(attr) ::= <<
<!
  Writes the parameter declaration for a concrete attribute.
  @param attr the attribute.
!>
final <if(attr.clob)>String<else><attr.javaType><endif> <attr.nameLowercased>,
>>

indirect_template(name, input, extra1, extra2) ::= <<
<!
  Calls the template matching given name, passing the input as argument.
  @param name the template name.
  @param input the arguments.
!>
<(name)(input=input, extra1=extra1, extra2=extra2)>
>>

custom_select(cs, table, input) ::= <<
<!
 Writes the code for a custom select query.
 @param cs the custom select.
 @param table the table.
 @param input the input.
!>
<if(!cs.dynamic)>
/**
 * Custom select \<i><cs.id>\</i>:\<br/>
 * \<b><cs.description>\</b>.
 <cs.parameters:attribute_javadoc(name=it.nameLowercased); separator="\n">
 * @return the \<i><cs.resultClass>\</i> information retrieved.
 * @throws DataAccessException if the operation fails.
 */
<cs.result:{rs|<if(table.voDecorated)><if(rs.implicitProperty)>
public <cs.resultClass> <cs.nameUncapitalized>(
<else>
<if(rs.multiple)>
public <cs.resultClass> <cs.nameUncapitalized>(
<else>
public <cs.resultClass>Decorator <cs.nameUncapitalized>(
<endif>
<endif>
<else>
public <cs.resultClass> <cs.nameUncapitalized>(
<endif>}>
    <cs.parameters:attribute_declaration(attr=it); separator=",\n">)
  throws DataAccessException
{
    return
        <cs.nameUncapitalized>(
            <cs.parameters:{<it.nameLowercased>,}; separator="\n">
            new PreparedStatementCreatorFactory(
                auditSql(<cs.idAsConstant>_SQL)),
            new Object[]
            {
                <cs.parameters:custom_select_parameter_value(
                  name=it.nameLowercased,
                  objectType=it.objectType,
                  object=it.object); separator=",\n">
            },
            getDataSource());
}

/**
 * Custom select \<i><cs.id>\</i>:\<br/>
 * \<b><cs.description>\</b>.
 <cs.parameters:attribute_javadoc(name=it.nameLowercased); separator="\n">
 * @param preparedStatementCreatorFactory the
 * {@link PreparedStatementCreatorFactory} instance
 * specific for this operation.
 * @param params the query parameters.
 * @param dataSource the {@link DataSource{@link  instance.
 * @return the \<i><cs.resultClass>\</i> information retrieved.
 * @throws DataAccessException if the operation fails.
 <precondition_notnull("preparedStatementCreatorFactory")>
 <precondition_notnull("params")>
 <precondition_notnull("dataSource")>
 */
<cs.result:{rs|<if(table.voDecorated)><if(rs.implicitProperty)>
protected <cs.resultClass> <cs.nameUncapitalized>(
<else>
<if(rs.multiple)>
protected <cs.resultClass> <cs.nameUncapitalized>(
<else>
protected <cs.resultClass>Decorator <cs.nameUncapitalized>(
<endif>
<endif>
<else>
protected <cs.resultClass> <cs.nameUncapitalized>(
<endif>}>
    <cs.parameters:attribute_isolated_declaration(attr=it); separator="\n">
    final PreparedStatementCreatorFactory preparedStatementCreatorFactory,
    final Object[] params,
    final DataSource dataSource)
  throws DataAccessException
{
    return
        <cs.nameUncapitalized>(
            <cs.parameters:{<it.nameLowercased>,}; separator="\n">
            preparedStatementCreatorFactory,
            params,
            new DataSourceTransactionManager(dataSource));
}

/**
 * Custom select \<i><cs.id>\</i>:\<br/>
 * \<b><cs.description>\</b>.
 <cs.parameters:attribute_javadoc(name=it.nameLowercased); separator="\n">
 * @param preparedStatementCreatorFactory the
 * {@link PreparedStatementCreatorFactory} instance
 * specific for this operation.
 * @param params the query parameters.
 * @param transactionManager the {@link PlatformTransactionManager{@link 
 * instance.
 * @return the \<i><cs.resultClass>\</i> information retrieved.
 * @throws DataAccessException if the operation fails.
 <precondition_notnull("preparedStatementCreatorFactory")>
 <precondition_notnull("params")>
 <precondition_notnull("transactionManager")>
 */
<cs.result:{rs|<if(table.voDecorated)><if(rs.implicitProperty)>
protected <cs.resultClass> <cs.nameUncapitalized>(
<else>
<if(rs.multiple)>
protected <cs.resultClass> <cs.nameUncapitalized>(
<else>
protected <cs.resultClass>Decorator <cs.nameUncapitalized>(
<endif>
<endif>
<else>
protected <cs.resultClass> <cs.nameUncapitalized>(
<endif>}>
    <cs.parameters:attribute_isolated_declaration(attr=it); separator="\n">
    final PreparedStatementCreatorFactory preparedStatementCreatorFactory,
    final Object[] params,
    final PlatformTransactionManager transactionManager)
  throws DataAccessException
{
    <custom_select_result_declaration(sql=cs, result=cs.result, table=table)>

    result =
        <cs.nameUncapitalized>(
            <cs.parameters:{<it.nameLowercased>,}; separator="\n">
            preparedStatementCreatorFactory,
            params,
            new TransactionTemplate(transactionManager));

    return result;
}

/**
 * Custom select \<i><cs.id>\</i>:\<br/>
 * \<b><cs.description>\</b>.
 <cs.parameters:attribute_javadoc(name=it.nameLowercased); separator="\n">
 * @param preparedStatementCreatorFactory the
 * {@link PreparedStatementCreatorFactory} instance
 * specific for this operation.
 * @param params the query parameters.
 * @param transactionTemplate the {@link TransactionTemplate{@link 
 * instance.
 * @return the \<i><cs.resultClass>\</i> information retrieved.
 * @throws DataAccessException if the operation fails.
 <precondition_notnull("preparedStatementCreatorFactory")>
 <precondition_notnull("params")>
 <precondition_notnull("transactionTemplate")>
 */
<cs.result:{rs|<if(table.voDecorated)><if(rs.implicitProperty)>
protected <cs.resultClass> <cs.nameUncapitalized>(
<else>
<if(rs.multiple)>
protected <cs.resultClass> <cs.nameUncapitalized>(
<else>
protected <cs.resultClass>Decorator <cs.nameUncapitalized>(
<endif>
<endif>
<else>
protected <cs.resultClass> <cs.nameUncapitalized>(
<endif>}>
    <cs.parameters:attribute_isolated_declaration(attr=it); separator="\n">
    final PreparedStatementCreatorFactory preparedStatementCreatorFactory,
    final Object[] params,
    final TransactionTemplate transactionTemplate)
  throws DataAccessException
{
    <custom_select_result_declaration(sql=cs, result=cs.result, table=table)>

    /*
    preparedStatementCreatorFactory.setResultSetType(..);
    preparedStatementCreatorFactory.setUpdatableResults(..);
    preparedStatementCreatorFactory.setReturnGeneratedKeys(..);
    preparedStatementCreatorFactory.setGeneratedKeysColumnNames(..);
    */

    <cs.parameters:custom_select_parameter_type_specification(
      type=it.sqlType); separator="\n">

    result =
        <custom_select_template_call(sql=cs, result=cs.result, table=table)>

    return result;
}
<endif>
<endif>
>>

custom_select_parameter_type_specification(type) ::= <<
<!
  Specifies the type of the parameter of a custom select.
  @param type the SQL type.
!>
preparedStatementCreatorFactory.addParameter(
    new SqlParameter(Types.<type>));
>>

custom_select_parameter_value(name, objectType, object) ::= <<
<!
  Writes the value for a parameter of a custom select.
  @param name the parameter name.
  @param objectType the object type of the parameter.
  @param object whether the parameter type is a class or a primitive.
!>
<if(object)>
<name>
<else>
new <objectType>(<name>)
<endif>
>>

custom_update_or_insert(cs, input) ::= <<
<!
 Writes the subtemplate for custom updates or inserts.
  @param cs the custom sql.
  @param input the input.
!>
<if(!cs.dynamic)>
/**
 * Custom sql \<i><cs.id>\</i>:\<br/>
 * \<b><cs.description>\</b>.
 <cs.parameters:attribute_javadoc(name=it.nameLowercased); separator="\n">
 * @return the number of entities updated.
 * @throws DataAccessException if the operation fails.
 */
public int <cs.nameUncapitalized>(
    <cs.parameters:attribute_declaration(attr=it); separator=",\n">)
  throws DataAccessException
{
    int result = -10;

    PreparedStatementCreatorFactory
        preparedStatementCreatorFactory =
            new PreparedStatementCreatorFactory(
                auditSql(<cs.idAsConstant>_SQL));

    /*
    t_PreparedStatementCreatorFactory.setResultSetType(..);
    t_PreparedStatementCreatorFactory.setUpdatableResults(..);
    t_PreparedStatementCreatorFactory.setReturnGeneratedKeys(..);
    t_PreparedStatementCreatorFactory.setGeneratedKeysColumnNames(..);
     */

    <cs.parameters:custom_select_parameter_type_specification(
      type=it.sqlType); separator="\n">

    Object[] params =
       new Object[]
       {
           <cs.parameters:custom_select_parameter_value(
             name=it.nameLowercased,
             objectType=it.objectType,
             object=it.object); separator=",\n">
        };

     DataSourceTransactionManager transactionManager =
        new DataSourceTransactionManager(getDataSource());
    TransactionTemplate transactionTemplate =
        new TransactionTemplate(transactionManager);

    Object t_Result =
        transactionTemplate.execute(
            new UpdateTransactionCallback(
                preparedStatementCreatorFactory
                    .newPreparedStatementCreator(params),
                preparedStatementCreatorFactory
                    .newPreparedStatementSetter(params),
                this));


    if  (t_Result instanceof Integer)
    {
        result = ((Integer) t_Result).intValue();
    }

    /*
    result =
        update(
            t_PreparedStatementCreatorFactory
               .newPreparedStatementCreator(params),
            t_PreparedStatementCreatorFactory
               .newPreparedStatementSetter(params));
     */

    return result;
}
<endif>
>>

custom_select_for_update(cs, table, input) ::= <<
<!
 Writes the code for a custom select for update.
 @param cs the custom select.
 @param table the table.
 @param input the input.
!>
<if(!cs.dynamic)>
/**
 * Custom select for update \<i><cs.id>\</i>:\<br/>
 * \<b><cs.description>\</b>.
 <cs.parameters:attribute_javadoc(name=it.nameLowercased); separator="\n">
 * @return the \<i><cs.resultClass>\</i> information retrieved.
 * @throws DataAccessException if the operation fails.
 */
<if(cs.resultClass)>
<cs.result:{rs|<if(table.voDecorated)><if(rs.implicitProperty)>
public <cs.resultClass> <cs.nameUncapitalized>(
<else>
<if(rs.multiple)>
public <cs.resultClass> <cs.nameUncapitalized>(
<else>
public <cs.resultClass>Decorator <cs.nameUncapitalized>(
<endif>
<endif>
<else>
public <cs.resultClass> <cs.nameUncapitalized>(
<endif>}>
<else>
public void <cs.nameUncapitalized>(
<endif>

    <cs.parameters:attribute_declaration(attr=it); separator=",\n">)
  throws DataAccessException
{
<if(cs.resultClass)>
<cs.result:{rs|<if(table.voDecorated)><if(!rs.implicitProperty)><if(rs.multiple)>
    <cs.resultClass> result = null;
<else>
    <cs.resultClass>Decorator result = null;
<endif>
<endif>
<else>
    <cs.resultClass> result = null;
<endif>}>
<else>
<endif>

    SqlQuery t_Query =
        new SqlQuery(
            getDataSource(), <cs.idAsConstant>_SQL);

<if(cs.resultClass)>
    List t_lResult = t_Query.execute();

    if  (   (t_lResult != null)
         && (t_lResult.size() > 0))
    {
        result = (<cs.resultClass>) t_lResult.get(0);
    }

    return result;
<else>
    t_Query.execute();
<endif>

}
<endif>
>>

inner_transaction_callbacks(daoName, voName, clobHandling) ::= <<
<!
 Generates the inner classes for transaction callbacks.
 @param daoName the DAO name.
 @param voName the value object for select-for-update operations.
 @param clobHandling whether the CLOBs need to be handled or not.
!>
/**
 * Transaction callback implementation to perform
 * {@link JdbcTemplate#update(PreparedStatementCreator, PreparedStatementSetter)}.
 */
protected static class AbstractTransactionCallback
    implements TransactionCallback
{
    /**
     * The {@link PreparedStatementCreator}.
     */
    private PreparedStatementCreator m__PreparedStatementCreator;

    /**
     * The {@link PreparedStatementSetter}.
     */
    private PreparedStatementSetter m__PreparedStatementSetter;

    /**
     * The {@link <daoName>DAO}.
     */
    private <daoName>DAO m__<daoName>DAO;

    /**
     * Creates a transaction callback.
     * @param creator the {@link PreparedStatementCreator} instance.
     * @param setter the {@link PreparedStatementSetter} instance.
     * @param dao the {@link <daoName>DAO} instance.
     */
    public AbstractTransactionCallback(
        final PreparedStatementCreator creator,
        final PreparedStatementSetter setter,
        final <daoName>DAO dao)
    {
        immutableSetPreparedStatementCreator(creator);
        immutableSetPreparedStatementSetter(setter);
        immutableSet<daoName>DAO(dao);
    }

    /**
     * Specifies the {@link PreparedStatementCreator} instance.
     * @param creator such instance.
     */
    private void immutableSetPreparedStatementCreator(
        final PreparedStatementCreator creator)
    {
        m__PreparedStatementCreator = creator;
    }

    /**
     * Specifies the {@link PreparedStatementCreator} instance.
     * @param creator such instance.
     */
    protected void setPreparedStatementCreator(
        final PreparedStatementCreator creator)
    {
        immutableSetPreparedStatementCreator(creator);
    }

    /**
     * Retrieves the {@link PreparedStatementCreator} instance.
     * @return such instance.
     */
    public PreparedStatementCreator getPreparedStatementCreator()
    {
        return m__PreparedStatementCreator;
    }

    /**
     * Specifies the {@link PreparedStatementSetter} instance.
     * @param setter such instance.
     */
    private void immutableSetPreparedStatementSetter(
        final PreparedStatementSetter setter)
    {
        m__PreparedStatementSetter = setter;
    }

    /**
     * Specifies the {@link PreparedStatementSetter} instance.
     * @param setter such instance.
     */
    protected void setPreparedStatementSetter(
        final PreparedStatementSetter setter)
    {
        immutableSetPreparedStatementSetter(setter);
    }

    /**
     * Retrieves the {@link PreparedStatementSetter} instance.
     * @return such instance.
     */
    public PreparedStatementSetter getPreparedStatementSetter()
    {
        return m__PreparedStatementSetter;
    }

    /**
     * Specifies the {@link <daoName>DAO} instance.
     * @param dao the DAO instance.
     */
    private void immutableSet<daoName>DAO(final <daoName>DAO dao)
    {
        m__<daoName>DAO = dao;
    }

    /**
     * Specifies the {@link <daoName>DAO} instance.
     * @param dao the DAO instance.
     */
    protected void set<daoName>DAO(final <daoName>DAO dao)
    {
        immutableSet<daoName>DAO(dao);
    }

    /**
     * Retrieves the {@link <daoName>DAO} instance.
     * @return such DAO.
     */
    public <daoName>DAO get<daoName>DAO()
    {
        return m__<daoName>DAO;
    }

    /**
     * Executes the transactional operation.
     * @param status the transaction status.
     * @return the transaction result.
     */
    public Object doInTransaction(final TransactionStatus status)
    {
        return
            doInTransaction(
                status,
                getPreparedStatementCreator(),
                getPreparedStatementSetter(),
                get<daoName>DAO());
    }

    /**
     * Executes the transactional operation.
     * @param status the transaction status.
     * @param creator the {@link PreparedStatementCreator} instance.
     * @param setter the {@link PreparedStatementSetter} instance.
     * @param dao the {@link <daoName>DAO} instance.
     * @return {@link null} in either case (this method is meant
     * to be overriden by subclasses, but cannot be defined \<i>abstract\</i>
     * since the inner class is \<i>static\</i>.
     */
    protected Object doInTransaction(
        final TransactionStatus status,
        final PreparedStatementCreator creator,
        final PreparedStatementSetter setter,
        final <daoName>DAO dao)
    {
        return null;
    }
}

/**
 * Transaction callback implementation to perform
 * {@link JdbcTemplate#update(PreparedStatementCreator, PreparedStatementSetter)}.
 */
protected static class UpdateTransactionCallback
    extends AbstractTransactionCallback
{
    /**
     * Creates a transaction callback.
     * @param creator the {@link PreparedStatementCreator} instance.
     * @param setter the {@link PreparedStatementSetter} instance.
     * @param dao the {@link <daoName>DAO} instance.
     */
    public UpdateTransactionCallback(
        final PreparedStatementCreator creator,
        final PreparedStatementSetter setter,
        final <daoName>DAO dao)
    {
        super(creator, setter, dao);
    }

    /**
     * Executes the transactional operation.
     * @param status the transaction status.
     * @param creator the {@link PreparedStatementCreator} instance.
     * @param setter the {@link PreparedStatementSetter} instance.
     * @param dao the {@link <daoName>DAO} instance.
     * @return the transaction result.
     */
    protected Object doInTransaction(
        final TransactionStatus status,
        final PreparedStatementCreator creator,
        final PreparedStatementSetter setter,
        final <daoName>DAO dao)
    {
        return new Integer(dao.update(creator, setter));
    }
}

/**
 * Transaction callback implementation to perform
 * {@link JdbcTemplate.query(PreparedStatementCreator, PreparedStatementSetter)}.
 */
protected static class QueryTransactionCallback
    extends AbstractTransactionCallback
{
    /**
     * The optional SQL.
     */
    private String m__strSQL;

    /**
     * The {@link ResultSetExtractor}.
     */
    private ResultSetExtractor m__ResultSetExtractor;

    /**
     * Creates a transaction callback.
     * @param sql the SQL sentence.
     * @param extractor the {@link ResultSetExtractor} instance.
     * @param dao the {@link <daoName>DAO} instance.
     */
    public QueryTransactionCallback(
        final String sql,
        final ResultSetExtractor extractor,
        final <daoName>DAO dao)
    {
        super(null, null, dao);
        immutableSetSQL(sql);
        immutableSetResultSetExtractor(extractor);
    }

    /**
     * Creates a transaction callback.
     * @param creator the {@link PreparedStatementCreator} instance.
     * @param setter the {@link PreparedStatementSetter} instance.
     * @param extractor the {@link ResultSetExtractor} instance.
     * @param dao the {@link <daoName>DAO} instance.
     */
    public QueryTransactionCallback(
        final PreparedStatementCreator creator,
        final PreparedStatementSetter setter,
        final ResultSetExtractor extractor,
        final <daoName>DAO dao)
    {
        super(creator, setter, dao);
        immutableSetResultSetExtractor(extractor);
    }

    /**
     * Specifies the SQL sentence.
     * @param sql such sentence.
     */
    private void immutableSetSQL(final String sql)
    {
        m__strSQL = sql;
    }

    /**
     * Specifies the SQL sentence.
     * @param sql such sentence.
     */
    protected void setSQL(final String sql)
    {
        immutableSetSQL(sql);
    }

    /**
     * Retrieves the SQL sentence.
     * @return such sentence.
     */
    public String getSQL()
    {
        return m__strSQL;
    }

    /**
     * Specifies the {@link ResultSetExtractor} instance.
     * @param extractor such instance.
     */
    private void immutableSetResultSetExtractor(
        final ResultSetExtractor extractor)
    {
        m__ResultSetExtractor = extractor;
    }

    /**
     * Specifies the {@link ResultSetExtractor} instance.
     * @param extractor such instance.
     */
    protected void setResultSetExtractor(
        final ResultSetExtractor extractor)
    {
        immutableSetResultSetExtractor(extractor);
    }

    /**
     * Retrieves the {@link ResultSetExtractor} instance.
     * @return such instance.
     */
    public ResultSetExtractor getResultSetExtractor()
    {
        return m__ResultSetExtractor;
    }

    /**
     * Executes the transactional operation.
     * @param status the transaction status.
     * @param creator the {@link PreparedStatementCreator} instance.
     * @param setter the {@link PreparedStatementSetter} instance.
     * @param dao the {@link <daoName>DAO} instance.
     * @return the transaction result.
     */
    protected Object doInTransaction(
        final TransactionStatus status,
        final PreparedStatementCreator creator,
        final PreparedStatementSetter setter,
        final <daoName>DAO dao)
    {
        return
            doInTransaction(
                status,
                creator,
                setter,
                getSQL(),
                getResultSetExtractor(),
                dao);
    }

    /**
     * Executes the transactional operation.
     * @param status the transaction status.
     * @param creator the {@link PreparedStatementCreator} instance.
     * @param setter the {@link PreparedStatementSetter} instance.
     * @param sql the sql (optional).
     * @param extractor the {@link ResultSetExtractor} instance.
     * @param dao the {@link <daoName>DAO} instance.
     * @result the transaction result.
     */
    protected Object doInTransaction(
        final TransactionStatus status,
        final PreparedStatementCreator creator,
        final PreparedStatementSetter setter,
        final String sql,
        final ResultSetExtractor extractor,
        final <daoName>DAO dao)
    {
        Object result = null;

        if  (sql == null)
        {
            result = dao.query(creator, setter, extractor);
        }
        else
        {
            result = dao.query(auditSql(sql), extractor);
        }

        return result;
    }
}

<if(clobHandling)>
<if(voName)>
/**
 * Transaction callback implementation to perform a
 * \<i>select for update}.
 */
protected static class SelectForUpdateTransactionCallback
    extends QueryTransactionCallback
    implements PreparedStatementCallback
{
    /**
     * The result of the query. This make the class stateful, so
     * instances cannot be reused.
     */
    private <voName> m__Result;

    /**
     * Creates a transaction callback.
     * @param creator the {@link PreparedStatementCreator} instance.
     * @param setter the {@link PreparedStatementSetter} instance.
     * @param extractor the {@link ResultSetExtractor} instance.
     * @param dao the {@link <daoName>DAO}
     * instance.
     */
    public SelectForUpdateTransactionCallback(
        final PreparedStatementCreator creator,
        final PreparedStatementSetter setter,
        final ResultSetExtractor extractor,
        final <daoName>DAO dao)
    {
        super(creator, setter, extractor, dao);
    }

    /**
     * Specifies the result of the operation.
     * @param operationResult such information.
     */
    protected final void immutableSetOperationResult(
        final <voName> operationResult)
    {
        m__Result = operationResult;
    }

    /**
     * Specifies the result of the operation.
     * @param operationResult such information.
     */
    protected void setOperationResult(
        final <voName> operationResult)
    {
        immutableSetOperationResult(operationResult);
    }

    /**
     * Specifies the result of the operation.
     * @return such information.
     */
    public <voName> getOperationResult()
    {
        return m__Result;
    }

    /**
     * Executes the transactional operation.
     * @param status the transaction status.
     * @return the transaction result.
     */
    public Object doInTransaction(final TransactionStatus status)
    {
        return
            doInTransaction(
                status,
                getPreparedStatementCreator(),
                get<daoName>DAO());
    }

    /**
     * Executes the transactional operation.
     * @param status the transaction status.
     * @param creator the {@link PreparedStatementCreator} instance.
     * @param dao the {@link <daoName>DAO} instance.
     * @return the transaction result.
     */
    protected Object doInTransaction(
        final TransactionStatus status,
        final PreparedStatementCreator creator,
        final <daoName>DAO dao)
    {
        return dao.execute(creator, (PreparedStatementCallback) this);
    }

    /**
     * Manages the prepared statement logic.
     * @param preparedStatement the statement.
     * @return the result of the operation.
     * @throws SQLException if it gets thrown as result of the operation.
     * @throws DataAccessException if the data cannot be accessed for some
     * reason.
     */
    public Object doInPreparedStatement(
        final PreparedStatement preparedStatement)
      throws SQLException,
             DataAccessException
    {
        return
            doInPreparedStatement(
                preparedStatement,
                getPreparedStatementSetter(),
                getResultSetExtractor());
    }

    /**
     * Manages the prepared statement logic.
     * @param preparedStatement the statement.
     * @param preparedStatementSetter the prepared statement setter.
     * @param resultSetExtractor the result set extractor.
     * @return the result of the operation.
     * @throws SQLException if it gets thrown as result of the operation.
     * @throws DataAccessException if the data cannot be accessed for some
     * reason.
     */
    protected Object doInPreparedStatement(
        final PreparedStatement preparedStatement,
        final PreparedStatementSetter preparedStatementSetter,
        final ResultSetExtractor resultSetExtractor)
      throws SQLException,
             DataAccessException
    {
        Object result = null;

        // taken from JdbcTemplate, Spring 1.1.4
        ResultSet t_ResultSet = null;

        try
        {
            if  (preparedStatementSetter != null)
            {
                preparedStatementSetter.setValues(preparedStatement);
            }

            t_ResultSet = preparedStatement.executeQuery();

            result = resultSetExtractor.extractData(t_ResultSet);
        }
        finally
        {
            if  (preparedStatementSetter instanceof ParameterDisposer)
            {
                ((ParameterDisposer) preparedStatementSetter)
                    .cleanupParameters();
            }

            JdbcUtils.closeResultSet(t_ResultSet);
        }

        return result;
    }
}
<endif>
<endif>
>>

resultset_extractor_import(
  basePackageName,
  baseDAOSubpackageName,
  rdbSubpackageName,
  subpackageName,
  crseIdCapitalized) ::= <<
<!
  Generates the import statement of a custom resultset extractor.
  @param basePackageName the base package.
  @param baseDAOSubpackageName the base DAO subpackage.
  @param rdbSubpackageName the rdb subpackage.
  @param subpackageName the subpackage.
  @param crseIdCapitalized the custom resultset extractor identifier, capitalized.
!>
import <basePackageName>.<baseDAOSubpackageName>.<rdbSubpackageName>.<subpackageName>.<crseIdCapitalized>Extractor;
>>

resultset_extractor_constants(
  crseid,
  crseidCapitalized,
  crseidNormalizedUppercased) ::= <<
<!
  Generates the class constants for a custom resultset extractor.
  @param crseId the custom resultset extractor identifier.
  @param crseIdCapitalized the capitalized identifier of the custom resultset
  extractor.
  @param crseIdNormalizedUppercased the normalized, upper-cased identifier
  of the custom resultset extractor.
!>
/**
 * The result set extractor for \<i><crseid>\</i> custom query.
 */
public static final ResultSetExtractor
    <crseidNormalizedUppercased>_CUSTOM_EXTRACTOR =
        new <crseidCapitalized>Extractor();
>>

custom_select_result_declaration(sql, result, table) ::= <<
<!
 Generates code to declare the custom-select result.
 @param sql the custom select.
 @param result the sql result.
 @param table the table.
 !>
<if(result.implicitProperty)>
<implicit_attribute_declaration(result=result, attr=result.implicitProperty)>
<else>
<if(table.voDecorated)>
<if(result.multiple)>
<sql.resultClass> result = null;
<else>
<sql.resultClass>Decorator result = null;
<endif>
<else>
<sql.resultClass> result = null;
<endif>
<endif>

>>

implicit_attribute_declaration(result, attr) ::= <<
<!
 Generates the declaration of the property.
 @param result the custom result.
 @param attr the implicit property.
!>
<if(attr.nullable)>
<if(result.multiple)>
List result = null;
<else>
<result.classValue> result = null;
<endif>
<else>
<if(attr.numeric)>
<attr.type> result = 0;
<else>
<if(attr.boolean)>
<attr.type> result = false;
<else>
<attr.type> result = null;
<endif>
<endif>
<endif>

>>

implicit_custom_select_attribute_declaration(sql, attr) ::= <<
<!
 Generates the declaration of the property.
 @param sql the custom sql.
 @param attr the implicit property.
!>
<if(attr.nullable)>
<sql.resultClass> result = null;
<else>
<attr.javaType> result = null;
<endif>

>>

custom_select_template_call(sql, result, table) ::= <<
<!
 Generates the call to execute the custom select.
 @param sql the custom select.
 @param result the sql result.
 @param table the table.
 !>
<if(result.implicitProperty)>
<result.implicitProperty:{attr |
    <if(!attr.nullable)>((<attr.javaType>)
    (<actual_custom_select_template_call(sql=sql, result=result)>)).<attr.type>Value();
<else>(<sql.resultClass>)
     <actual_custom_select_template_call(sql=sql, result=result)>;
<endif>}>
<else><if(table.voDecorated)><if(result.multiple)>(<sql.resultClass>)<else>(<sql.resultClass>Decorator)<endif><else>(<sql.resultClass>)<endif>
     <actual_custom_select_template_call(sql=sql, result=result)>;
<endif>
>>

actual_custom_select_template_call(sql, result) ::= <<
<!
 Generates the actual call to the template for the custom select.
 @param sql the custom select.
 @param result the sql result.
 !>
transactionTemplate.execute(
    new QueryTransactionCallback(
        preparedStatementCreatorFactory
            .newPreparedStatementCreator(params),
        null,
        // calls setXXX twice
        // preparedStatementCreatorFactory
        //     .newPreparedStatementSetter(t_aParams),
        new <sql.resultIdCapitalized>Extractor(getDAOListener()),
        this))
>>

Integer_to_primitive(input) ::= <<
<!
 Generates the method call to convert the attribute into an int primitive.
 @param input the attribute.
!><input.nameLowercased>.intValue()>>

primitive_to_Integer(input) ::= <<
<!
 Generates the method call to convert the primitive into an Integer.
 @param input the attribute.
!><if(input.valueNull)>null<else>new Integer(<input.nameLowercased>)<endif>
>>

primitive_to_Integer_value(input) ::= <<
<!
 Generates the method call to convert the primitive into an Integer.
 @param input the attribute.
!><if(input.valueNull)>null<else>new Integer(<input.value>)<endif>
>>

Long_to_primitive(input) ::= <<
<!
 Generates the method call to convert the attribute into a long primitive.
 @param input the attribute.
!><input.nameLowercased>.longValue()>>

primitive_to_Long(input) ::= <<
<!
 Generates the method call to convert the primitive into a Long.
 @param input the attribute.
!><if(input.valueNull)>null<else>new Long(<input.nameLowercased>)<endif>
>>

primitive_to_Long_value(input) ::= <<
<!
 Generates the method call to convert the primitive into a Long.
 @param input the attribute.
!><if(input.valueNull)>null<else>new Long(<input.value>)<endif>
>>

Float_to_primitive(input) ::= <<
<!
 Generates the method call to convert the attribute into a float primitive.
 @param input the attribute.
!><input.nameLowercased>.floatValue()>>

primitive_to_Float(input) ::= <<
<!
 Generates the method call to convert the primitive into a Float.
 @param input the attribute.
!><if(input.valueNull)>null<else>new Float(<input.nameLowercased>)<endif>
>>

primitive_to_Float_value(input) ::= <<
<!
 Generates the method call to convert the primitive into a Float.
 @param input the attribute.
!><if(input.valueNull)>null<else>new Float(<input.value>)<endif>
>>

Double_to_primitive(input) ::= <<
<!
 Generates the method call to convert the attribute into a double primitive.
 @param input the attribute.
!><input.nameLowercased>.doubleValue()>>

primitive_to_Double(input) ::= <<
<!
 Generates the method call to convert the primitive into a Double.
 @param input the attribute.
!><if(input.valueNull)>null<else>new Double(<input.nameLowercased>)<endif>
>>

primitive_to_Double_value(input) ::= <<
<!
 Generates the method call to convert the primitive into a Double.
 @param input the attribute.
!><if(input.valueNull)>null<else>new Double(<input.value>)<endif>
>>

String_to_primitive(input) ::= <<
<!
 Don't try to convert the String to anything.
 @param input the attribute.
!><Object_to_primitive(input=input)>
>>

primitive_to_String(input) ::= <<
<!
 Don't try to convert the primitive to anything.
 @param input the attribute.
!><primitive_to_Object(input=input)>
>>

primitive_to_String_value(input) ::= <<
<!
 Don't try to convert the primitive to anything.
 @param input the attribute.
!>"<primitive_to_Object_value(input=input)>"
>>

BigDecimal_to_primitive(input) ::= <<
<!
 Don't try to convert the BigDecimal to anything.
 @param input the attribute.
!><Object_to_primitive(input=input)>
>>

primitive_to_BigDecimal(input) ::= <<
<!
 Don't try to convert the primitive to anything.
 @param input the attribute.
!><if(input.valueNull)>null<else>new BigDecimal("<input.nameLowerCased>")<endif>
>>

primitive_to_BigDecimal_value(input) ::= <<
<!
 Don't try to convert the primitive to anything.
 @param input the attribute.
!><if(input.valueNull)>null<else>new BigDecimal("<input.value>")<endif>
>>

Timestamp_to_primitive(input) ::= <<
<!
 Don't try to convert the Timestamp to anything.
 @param input the attribute.
!>
<if(input.date)>
new Timestamp(<input.nameLowercased>.getTime())
<else>
<Object_to_primitive(input=input)>
<endif>
>>

primitive_to_Timestamp(input) ::= <<
<!
 Don't try to convert the primitive to anything.
 @param input the attribute.
!><primitive_to_Object(input=input)>
>>

primitive_to_Timestamp_value(input) ::= <<
<!
 Don't try to convert the primitive to anything.
 @param input the attribute.
!><primitive_to_Object_value(input=input)>
>>

Object_to_primitive(input) ::= <<
<!
 Don't try to convert the attribute to anything.
 @param input the attribute.
!><input.nameLowercased>
>>

primitive_to_Object(input) ::= <<
<!
 Don't try to convert the attribute to anything.
 @param input the attribute.
!><input.nameLowercased>
>>

primitive_to_Object_value(input) ::= <<
<!
 Don't try to convert the attribute to anything.
 @param input the attribute.
!><input.value>
>>

type_checker(attribute) ::= <<
<!
 Type checker for given attribute
 @param attribute the attribute.
!><if(!attribute.primitive)><if(attribute.allowsNull)>/*@Nullable*/<else>/*@NonNull*/<endif><endif>
>>
